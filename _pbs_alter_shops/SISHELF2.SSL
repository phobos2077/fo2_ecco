/*
	Copyright 1998-2003 Interplay Entertainment Corp.  All rights reserved.
*/

/******************************************************************************************
        Item: Book shelf
        Locked: Yes
        Trapped: Yes
        Description: This is a generic locked and trapped wooden door.

        Log:
           Please note any changes that have been made to the file in Updated. Then comment
           the code which you have changed/altered/commented out. Please, do not delete any
           code which was written.

           Created: September 26, 1997

           Updated:
******************************************************************************************/


/* Include Files */
#include "..\headers\define.h"

#define NAME                    SCRIPT_SISHELF2

#include "..\headers\command.h"

#include "stock.h" // by phobos2077

/* Defines and Macros */

/* Door States */
#define STATE_ACTIVE                    (0)
#define STATE_INACTIVE                  (1)
#define STATE_WOOD                      (0)
#define STATE_METAL                     (1)
#define STATE_FRIDGE                    (2)
#define STATE_NON_DESTROY               (2)
#define STATE_STANDARD_LOCK             (0)
#define STATE_ELECTRIC_LOCK             (1)

/* Sets whether the door is locked or trapped */
#define LOCKED_STATUS                   STATE_ACTIVE
#define TRAPPED_STATUS                  STATE_ACTIVE
#define DOOR_STATUS                     STATE_WOOD
#define LOCK_STATUS                     STATE_STANDARD_LOCK

/* Penalties for Lock difficulty based on whether or not you are using lockpicks. */
#define Lock_Bonus                      (-20)
#define Lockpick_Bonus                  (0)

/* Penalties for disarming the trap */
#define Trap_Bonus                      (0)
#define Trap_Set_Bonus                  (-10)

/* Penalties for forcing the door open using strength */
#define Crowbar_Bonus                   (0)

/* Max and Min damage for the trap */
#define DOOR_STRENGTH                   (1)
#define MIN_DAMAGE                      (10)
#define MAX_DAMAGE                      (20)
#define Crowbar_Strain                  (2)

/* Experience Points for Skills */
#define Lockpick_Exp                    EXP_LOCKPICK_NORMAL
#define Traps_Exp                       EXP_TRAPS_NORMAL

/* Standard Script Procedures */
procedure start;
procedure use_p_proc;
procedure look_at_p_proc;
procedure description_p_proc;
procedure use_skill_on_p_proc;
procedure use_obj_on_p_proc;
procedure damage_p_proc;
procedure map_enter_p_proc;
procedure map_update_p_proc;

/* Script Specific Procedure Calls */
procedure Look_Traps_And_Locks;
procedure Look_Traps;
procedure Look_Locks;
procedure Skill_Disarm_Traps;
procedure Disarm_Traps;
procedure Unlock_Lock;
procedure Lockpick_Lock;
procedure Lockpick_Door;
procedure Lock_Door;
procedure Set_Lock;
procedure Set_Lockpick_Lock;
procedure Set_Trap;
procedure Pry_Door;
procedure Damage_Critter;


/*****************************************************************
   Local Variables which are saved. All Local Variables need to be
   prepended by LVAR_
*****************************************************************/

#define LVAR_Locked                     (0)
#define LVAR_Trapped                    (1)
#define LVAR_Found_Trap                 (2)
#define LVAR_Set_Door_Status            (3)
#define LVAR_Explosion_Attempts         (4)
#define LVAR_Gave_Locks_XP              (5)
#define LVAR_Gave_Traps_XP              (6)
#define LVAR_Restock_Time               (7)
#define LVAR_First_Restock              (8)
#define LVAR_Restock_Time_Fix           (9) //added by killap


/*******************************************************************
   Imported variables from the Map scripts. These should only be
   pointers and variables that need not be saved. If a variable
   Needs to be saved, make it a map variable (MVAR_)
*******************************************************************/
#define ANNOYTHRESH 2

import variable buster_obj;
import variable book_obj2;
import variable book_obj_look;



/*******************************************************************
   Local variables which do not need to be saved between map changes.
*******************************************************************/

variable Locks_Roll;
variable Traps_Roll;
variable Book_Annoy_Count;


/*******************************************************************
*******                         PROCEDURES                   *******
*******************************************************************/


/*******************************************************************
   The start procedure is the first procedure called when the map is
   first entered. Any initial information that needs to be set up
   should be placed in here.
*******************************************************************/

procedure start begin
   book_obj2 := self_obj;
end

/********************************************************************
   Any time that a critter tries to use this door will call this
   procedure. it will check to see if the door is trapped and locked.
********************************************************************/

procedure use_p_proc begin
/* Trap_Roll is a global variable to this script, defined at the beginning
   of the script. */
   if (buster_obj and buster_obj != -1) then begin
      script_overrides;
      book_obj_look := 2;
   end
 end

/***************************************************************************
   This is cursory glance description that the player will receive should
   he just pass the Action Cursor over. Examines which give more information
   need to be in the description_p_proc procedure.
***************************************************************************/

procedure look_at_p_proc begin
   script_overrides;

   display_msg(mstr(100));
end


/**********************************************************************************
   Should the player examine the door closely, then he should be allowed a lockpick
   roll, a traps roll and a perception roll. Depending on which rolls are made will
   determine how much information about the door will be given.
**********************************************************************************/

procedure description_p_proc begin
   script_overrides;
   display_msg(mstr(101));
end


/**********************************************************************************
   Should the player try using a skill on the door, here are where the skill rolls
   will be made. The ones which need to be in here are: Lockpick and Traps. Science
   and Repair can be added to this list to give more information about the door.
**********************************************************************************/

procedure use_skill_on_p_proc begin
   variable Skill_Used;

   Skill_Used:=action_being_used;


   if (Skill_Used == SKILL_TRAPS) then begin
       script_overrides; //added by killap
       if (local_var(LVAR_Trapped) == STATE_ACTIVE) then begin
           call Skill_Disarm_Traps;
       end
       else begin
           if (source_obj == dude_obj) then begin
               display_msg(mstr(195));
           end else begin
               display_msg(obj_name(source_obj)+mstr(200));
           end
       end
   end                                                          // End of Skill_Traps
   else begin
      if (buster_obj) then begin
         if (not skill_success(dude_obj, Skill_Used, -35)) then begin
            script_overrides;
            if (Book_Annoy_Count < ANNOYTHRESH) then begin
               if (Book_Annoy_Count == ANNOYTHRESH - 1) then begin
                  float_msg(buster_obj, mstr(207), FLOAT_MSG_RED);
               end else begin
                  float_msg(buster_obj, mstr(208), FLOAT_MSG_RED);
               end
            end else begin
               book_obj_look := 4;
            end
            Book_Annoy_Count += 1;
         end
      end
   end
end


/**********************************************************************************
   This is called when the player is using an object on the door. When the check is
   made to find out what is being used, obj_pid(obj_being_used_with) will need to
   be checked against a prototype.
**********************************************************************************/

procedure use_obj_on_p_proc begin
   variable Tool;

   Tool:=obj_pid(obj_being_used_with);

   if ((Tool == PID_DYNAMITE) or (Tool == PID_PLASTIC_EXPLOSIVES)) then begin
      script_overrides; //added by killap
      if (buster_obj) then begin
         float_msg(buster_obj, mstr(206), FLOAT_MSG_RED);
         book_obj_look := 4;
      end
   end else begin
      if (buster_obj) then begin
         script_overrides;
         if (Book_Annoy_Count < ANNOYTHRESH) then begin
            if (Book_Annoy_Count == ANNOYTHRESH - 1) then begin
               float_msg(buster_obj, mstr(207), FLOAT_MSG_WARNING);
            end else begin
               float_msg(buster_obj, mstr(208), FLOAT_MSG_RED);
            end
         end else begin
            book_obj_look := 4;
         end
         Book_Annoy_Count += 1;
      end
   end
end


/******************************************************************************************
   Should the door sustain damage from anything (ie, dynamite, plastic explosives, rockets,
   or any other forms of damage), this procedure will be called to destroy the door and
   free up the space.
******************************************************************************************/

procedure damage_p_proc begin
end


/***************************************************************************************
   Whenever the map is first entered, this procedure will be called. The main purpose of
   this procedure is to lock the door from the outset, rather than having to worry about
   it through Mapper. After the door has been unlocked, it will remain as such, unless
   the player locks it once more.
***************************************************************************************/

procedure map_enter_p_proc begin
   //added by killap
   variable tmp;
   variable special_item;
   //end added   
   
   if (buster_obj != -1 and buster_obj) then begin
   
      //added by killap - fix for game_time going negative after 7 years
      if (((game_time) < 0) and (local_var(LVAR_Restock_Time_Fix) == 0)) then begin
         set_local_var(LVAR_Restock_Time, game_time - 1);
         set_local_var(LVAR_Restock_Time_Fix, 1);
      end
      //end added
      
      if (local_var(LVAR_Restock_Time) < game_time) then begin
         //Common
         
                        //new added
      tmp := create_object(PID_FOOTLOCKER_CLEAN_LEFT,5,0);
      if (obj_is_carrying_obj_pid(self_obj, PID_NAV_COMPUTER_PARTS ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_NAV_COMPUTER_PARTS);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_NAVCOM_PARTS ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_NAVCOM_PARTS);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_COMPUTER_VOICE_MODULE ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_COMPUTER_VOICE_MODULE);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);
      end 
      if (obj_is_carrying_obj_pid(self_obj, PID_V15_COMPUTER_PART ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_V15_COMPUTER_PART);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);
      end 
      if (obj_is_carrying_obj_pid(self_obj, PID_GECK ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_GECK);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);
      end 
      if (obj_is_carrying_obj_pid(self_obj, PID_VERTIBIRD_PLANS ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_VERTIBIRD_PLANS);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);
      end 
      if (obj_is_carrying_obj_pid(self_obj, PID_TANKER_FOB ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_TANKER_FOB);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);   
      end 
      if (obj_is_carrying_obj_pid(self_obj, PID_CAR_FUEL_CELL ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_CAR_FUEL_CELL);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);   
      end 
      if (obj_is_carrying_obj_pid(self_obj, PID_CAR_FUEL_CELL_CONTROLLER ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_CAR_FUEL_CELL_CONTROLLER);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);   
      end 
      if (obj_is_carrying_obj_pid(self_obj, PID_CAR_FUEL_INJECTION ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_CAR_FUEL_INJECTION);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_VIC_RADIO ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_VIC_RADIO);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_VIC_WATER_FLASK ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_VIC_WATER_FLASK);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_HY_MAG_PART ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_HY_MAG_PART);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_DAY_PASS ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_DAY_PASS);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_FAKE_CITIZENSHIP ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_FAKE_CITIZENSHIP);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_CORNELIUS_GOLD_WATCH ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_CORNELIUS_GOLD_WATCH);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_RED_PASS_KEY ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_RED_PASS_KEY);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_BLUE_PASS_KEY ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_BLUE_PASS_KEY);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_GOLD_LOCKET ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_GOLD_LOCKET);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_YELLOW_PASS_KEY ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_YELLOW_PASS_KEY);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_ANNA_GOLD_LOCKET ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_ANNA_GOLD_LOCKET);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_TRAPPER_TOWN_KEY ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_TRAPPER_TOWN_KEY);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_GECKO_DATA_DISK ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_GECKO_DATA_DISK);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_REACTOR_DATA_DISK ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_REACTOR_DATA_DISK);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_YELLOW_REACTOR_KEYCARD ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_YELLOW_REACTOR_KEYCARD);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_RED_REACTOR_KEYCARD ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_RED_REACTOR_KEYCARD);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_PLASMA_TRANSFORMER ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_PLASMA_TRANSFORMER);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_MOORE_BAD_BRIEFCASE ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_MOORE_BAD_BRIEFCASE);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_MOORE_GOOD_BRIEFCASE ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_MOORE_GOOD_BRIEFCASE);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_LYNETTE_HOLO ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_LYNETTE_HOLO);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_WESTIN_HOLO ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_WESTIN_HOLO);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_SPY_HOLO ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_SPY_HOLO);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_DR_HENRY_PAPERS ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_DR_HENRY_PAPERS);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end      
      if (obj_is_carrying_obj_pid(self_obj, PID_PRESIDENTIAL_PASS ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_PRESIDENTIAL_PASS);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_VAULT_13_SHACK_KEY ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_VAULT_13_SHACK_KEY);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_EXCAVATOR_CHIP ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_EXCAVATOR_CHIP);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_RAMIREZ_BOX_CLOSED ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_RAMIREZ_BOX_CLOSED);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_RAMIREZ_BOX_CLOSED ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_RAMIREZ_BOX_CLOSED);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_RAMIREZ_BOX_OPEN ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_RAMIREZ_BOX_OPEN);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_RAMIREZ_BOX_CLOSED ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_RAMIREZ_BOX_CLOSED);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_BISHOPS_HOLODISK ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_BISHOPS_HOLODISK);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_ACCOUNT_BOOK ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_ACCOUNT_BOOK);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_ECON_HOLODISK ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_ECON_HOLODISK);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_CELL_DOOR_KEY ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_CELL_DOOR_KEY);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_SMITTY_MEAL ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_SMITTY_MEAL);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_BECKY_BOOK ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_BECKY_BOOK);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_ENLIGHTENED_ONE_LETTER ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_ENLIGHTENED_ONE_LETTER);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_K9_MOTIVATOR ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_K9_MOTIVATOR);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      if (obj_is_carrying_obj_pid(self_obj, PID_PRES_ACCESS_KEY ) > 0) then begin
         special_item := obj_carrying_pid_obj(self_obj, PID_PRES_ACCESS_KEY);
         rm_obj_from_inven(self_obj,special_item);
         add_obj_to_inven(tmp, special_item);  
      end
      //end new added
         
         destroy_obj_inven(self_obj); //added by killap - one of the preventives I am adding towards the "too many items bug"
         
         //Common
	     check_restock_item(PID_KNIFE, 1, 5, 100)
         check_restock_item(PID_CLUB, 1, 5, 100)
         check_restock_item(PID_SPEAR, 1, 5, 100)
         check_restock_item(PID_ROCK, 1, 5, 100)
         check_restock_item(PID_CROWBAR, 1, 5, 100)
         check_restock_item(PID_BRASS_KNUCKLES, 1, 5, 100)
         check_restock_item(PID_THROWING_KNIFE, 5, 15, 100)
         check_restock_item(PID_PBS_THROWING_AXE, 1, 3, 100) // new
         check_restock_item(PID_COMBAT_KNIFE, 1, 5, 100)

         //Uncommon
         check_restock_item(PID_SPIKED_KNUCKLES, 1, 2, 60)
         check_restock_item(PID_CATTLE_PROD, 1, 1, 60)
         check_restock_item(PID_SHARP_SPEAR, 1, 1, 60)
         check_restock_item(PID_SWITCHBLADE, 1, 1, 60)

         //Rare
         check_restock_item(PID_RIPPER, 1, 1, 30)

         //Really rare
         check_restock_item(PID_POWER_FIST, 1, 1, 5)

         //check_restock_item(PID_RIPPER, 1, 2, 25) - should be rare, see above (phobos2077)
         //check_restock_item(PID_223_PISTOL, 1, 3, 100) - removed intentionally  (phobos2077)
         check_restock_item(PID_10MM_JHP, 5, 10, 100)
         check_restock_item(PID_SHOTGUN_SHELLS, 5, 10, 100)

         set_local_var(LVAR_Restock_Time, (random(2,4) * ONE_GAME_DAY) + game_time);
         
         //new added - killap
         move_obj_inven_to_obj(tmp, self_obj);
         destroy_object(tmp);
         //end new added
         
      end
   end
end


/**************************************************************************************
   This procedure gets called roughly every 30 seconds of real time. It is used to make
   sure that the door does not lock on it's own and that the player will be able to get
   through once he has unlocked the door. Once more, this is so that locking and
   unlocking do not need to be done in Mapper.
**************************************************************************************/

procedure map_update_p_proc begin
end


/*************************************************************************************
   This is the set of conditions for when you look at a locked and trapped door, based
   on your lockpick and traps skills and perception to notice things.
*************************************************************************************/

procedure Look_Traps_And_Locks begin
   variable Perception_Check;
   variable Traps_Check;
   variable Locks_Check;

   Perception_Check:=do_check(dude_obj,STAT_pe,0);
   Traps_Check:=roll_vs_skill(dude_obj,SKILL_TRAPS,0);
   Locks_Check:=roll_vs_skill(dude_obj,SKILL_LOCKPICK,0);

   if (is_success(Perception_Check)) then begin

/*************************************************************************************************/

      /* Critical Success of a Perception Check  (Start)*/

       if (is_critical(Perception_Check)) then begin

           if (is_success(Traps_Check)) then begin
               set_local_var(LVAR_Found_Trap,1);                // player has found the trap

      /* Critical Success of a Traps Check  (Start)*/

               if (is_critical(Traps_Check)) then begin

                   if (is_success(Locks_Check)) then begin
                       if (is_critical(Locks_Check)) then begin
                           display_msg(mstr(102));
                       end                                      // critical success (Locks)

                       else begin
                           display_msg(mstr(103));
                       end                                      // regular success (Locks)
                   end

                   else if (is_critical(Locks_Check)) then begin
                       display_msg(mstr(104));
                   end                                          // critical Failure (Locks)

                   else begin
                       display_msg(mstr(105));
                   end                                          // end of regular failure (Locks)
               end                                              // critical success (Traps)

      /* Success of a Traps Check  (Start)*/

               else begin
                   if (is_success(Locks_Check)) then begin
                       if (is_critical(Locks_Check)) then begin
                           display_msg(mstr(106));
                       end                                      // critical success (Locks)

                       else begin
                           display_msg(mstr(107));
                       end                                      // regular success (Locks)
                   end

                   else if (is_critical(Locks_Check)) then begin
                       display_msg(mstr(108));
                   end                                          // critical Failure (Locks)

                   else begin
                       display_msg(mstr(109));
                   end                                          // end of regular failure (Locks)
               end                                              // regular success (Traps)
           end

      /* Critical Failure of a Traps Check  (Start)*/

           else if (is_critical(Traps_Check)) then begin
               if (is_success(Locks_Check)) then begin
                   if (is_critical(Locks_Check)) then begin
                       display_msg(mstr(110));
                   end                                          // critical success (Locks)

                   else begin
                       display_msg(mstr(111));
                   end                                          // regular success (Locks)
               end

               else if (is_critical(Locks_Check)) then begin
                   display_msg(mstr(112));
               end                                              // critical Failure (Locks)

               else begin
                   display_msg(mstr(113));
               end                                              // end of regular failure (Locks)
          end                                                   // critical Failure (Traps)

      /* Failure of a Traps Check  (Start)*/

           else begin
               if (is_success(Locks_Check)) then begin
                   if (is_critical(Locks_Check)) then begin
                       display_msg(mstr(114));
                   end                                          // critical success (Locks)

                   else begin
                       display_msg(mstr(115));
                   end                                          // regular success (Locks)
               end

               else if (is_critical(Locks_Check)) then begin
                   display_msg(mstr(116));
               end                                              // critical Failure (Locks)

               else begin
                   display_msg(mstr(117));
               end                                              // end of regular failure (Locks)
           end                                                  // regular failure (Traps)
       end                                                      // critical success (Stat_Pe)

      /* Critical Success of a Perception Check  (Finish)*/

/*************************************************************************************************/

      /* Success of a Perception Check  (Start)*/

       else begin
           if (is_success(Traps_Check)) then begin
               set_local_var(LVAR_Found_Trap,1);                // player has found the trap

      /* Critical Success of a Traps Check  (Start)*/

               if (is_critical(Traps_Check)) then begin

                   if (is_success(Locks_Check)) then begin
                       if (is_critical(Locks_Check)) then begin
                           display_msg(mstr(118));
                       end                                      // critical success (Locks)

                       else begin
                           display_msg(mstr(119));
                       end                                      // regular success (Locks)
                   end

                   else if (is_critical(Locks_Check)) then begin
                       display_msg(mstr(120));
                   end                                          // critical Failure (Locks)

                   else begin
                       display_msg(mstr(121));
                   end                                          // end of regular failure (Locks)
               end                                              // critical success (Traps)

      /* Success of a Traps Check  (Start)*/

               else begin
                   if (is_success(Locks_Check)) then begin
                       if (is_critical(Locks_Check)) then begin
                           display_msg(mstr(122));
                       end                                      // critical success (Locks)

                       else begin
                           display_msg(mstr(123));
                       end                                      // regular success (Locks)
                   end

                   else if (is_critical(Locks_Check)) then begin
                       display_msg(mstr(124));
                   end                                          // critical Failure (Locks)

                   else begin
                       display_msg(mstr(125));
                   end                                          // end of regular failure (Locks)
               end                                              // regular success (Traps)
           end

      /* Critical Failure of a Traps Check  (Start)*/

           else if (is_critical(Traps_Check)) then begin
               if (is_success(Locks_Check)) then begin
                   if (is_critical(Locks_Check)) then begin
                       display_msg(mstr(126));
                   end                                          // critical success (Locks)

                   else begin
                       display_msg(mstr(127));
                   end                                          // regular success (Locks)
               end

               else if (is_critical(Locks_Check)) then begin
                   display_msg(mstr(128));
               end                                              // critical Failure (Locks)

               else begin
                   display_msg(mstr(129));
               end                                              // end of regular failure (Locks)
           end                                                  // critical Failure (Traps)

      /* Failure of a Traps Check  (Start)*/

           else begin
               if (is_success(Locks_Check)) then begin
                   if (is_critical(Locks_Check)) then begin
                       display_msg(mstr(130));
                   end                                          // critical success (Locks)

                   else begin
                       display_msg(mstr(131));
                   end                                          // regular success (Locks)
               end

               else if (is_critical(Locks_Check)) then begin
                   display_msg(mstr(132));
               end                                              // critical Failure (Locks)

               else begin
                   display_msg(mstr(133));
               end                                              // end of regular failure (Locks)
           end                                                  // regular failure (Traps)
       end                                                      // regular success (Stat_pe)
   end

      /* Success of a Perception Check  (Finish)*/

/*************************************************************************************************/

      /* Critical Failure of a Perception Check  (Start)*/

   else if (is_critical(Perception_Check)) then begin
       if (is_success(Traps_Check)) then begin
           set_local_var(LVAR_Found_Trap,1);                    // player has found the trap

      /* Critical Success of a Traps Check  (Start)*/

           if (is_critical(Traps_Check)) then begin

               if (is_success(Locks_Check)) then begin
                   if (is_critical(Locks_Check)) then begin
                       display_msg(mstr(134));
                   end                                          // critical success (Locks)

                   else begin
                       display_msg(mstr(135));
                   end                                          // regular success (Locks)
               end

               else if (is_critical(Locks_Check)) then begin
                   display_msg(mstr(136));
               end                                              // critical Failure (Locks)

               else begin
                   display_msg(mstr(137));
               end                                              // end of regular failure (Locks)
           end                                                  // critical success (Traps)

      /* Success of a Traps Check  (Start)*/

           else begin
               if (is_success(Locks_Check)) then begin
                   if (is_critical(Locks_Check)) then begin
                       display_msg(mstr(138));
                   end                                          // critical success (Locks)

                   else begin
                       display_msg(mstr(139));
                   end                                          // regular success (Locks)
               end

               else if (is_critical(Locks_Check)) then begin
                   display_msg(mstr(140));
               end                                              // critical Failure (Locks)

               else begin
                   display_msg(mstr(141));
               end                                              // end of regular failure (Locks)
           end                                                  // regular success (Traps)
       end

      /* Critical Failure of a Traps Check  (Start)*/

       else if (is_critical(Traps_Check)) then begin
           if (is_success(Locks_Check)) then begin
               if (is_critical(Locks_Check)) then begin
                   display_msg(mstr(142));
               end                                              // critical success (Locks)

               else begin
                   display_msg(mstr(143));
               end                                              // regular success (Locks)
           end

           else if (is_critical(Locks_Check)) then begin
               display_msg(mstr(144));
           end                                                  // critical Failure (Locks)

           else begin
               display_msg(mstr(145));
           end                                                  // end of regular failure (Locks)
       end                                                      // critical Failure (Traps)

      /* Failure of a Traps Check  (Start)*/

       else begin
           if (is_success(Locks_Check)) then begin
               if (is_critical(Locks_Check)) then begin
                   display_msg(mstr(146));
               end                                              // critical success (Locks)

               else begin
                   display_msg(mstr(147));
               end                                              // regular success (Locks)
           end

           else if (is_critical(Locks_Check)) then begin
               display_msg(mstr(148));
           end                                                  // critical Failure (Locks)

           else begin
               display_msg(mstr(149));
           end                                                  // end of regular failure (Locks)
       end                                                      // regular failure (Traps)
   end                                                          // Critical Failure (Stat_pe)

      /* Critical Failure of a Perception Check  (Finish)*/

/*************************************************************************************************/

      /* Failure of a Perception Check  (Start)*/

   else begin
       if (is_success(Traps_Check)) then begin
           set_local_var(LVAR_Found_Trap,1);                    // player has found the trap

      /* Critical Success of a Traps Check  (Start)*/

           if (is_critical(Traps_Check)) then begin

               if (is_success(Locks_Check)) then begin
                   if (is_critical(Locks_Check)) then begin
                       display_msg(mstr(150));
                   end                                          // critical success (Locks)

                   else begin
                       display_msg(mstr(151));
                   end                                          // regular success (Locks)
               end

               else if (is_critical(Locks_Check)) then begin
                   display_msg(mstr(152));
               end                                              // critical Failure (Locks)

               else begin
                   display_msg(mstr(153));
               end                                              // end of regular failure (Locks)
           end                                                  // critical success (Traps)

      /* Success of a Traps Check  (Start)*/

           else begin
               if (is_success(Locks_Check)) then begin
                   if (is_critical(Locks_Check)) then begin
                       display_msg(mstr(154));
                   end                                          // critical success (Locks)

                   else begin
                       display_msg(mstr(155));
                   end                                          // regular success (Locks)
               end

               else if (is_critical(Locks_Check)) then begin
                   display_msg(mstr(156));
               end                                              // critical Failure (Locks)

               else begin
                   display_msg(mstr(157));
               end                                              // end of regular failure (Locks)
           end                                                  // regular success (Traps)
       end

      /* Critical Failure of a Traps Check  (Start)*/

       else if (is_critical(Traps_Check)) then begin
           if (is_success(Locks_Check)) then begin
               if (is_critical(Locks_Check)) then begin
                   display_msg(mstr(158));
               end                                              // critical success (Locks)

               else begin
                   display_msg(mstr(159));
               end                                              // regular success (Locks)
           end

           else if (is_critical(Locks_Check)) then begin
               display_msg(mstr(160));
           end                                                  // critical Failure (Locks)

           else begin
               display_msg(mstr(161));
           end                                                  // end of regular failure (Locks)
       end                                                      // critical Failure (Traps)

      /* Failure of a Traps Check  (Start)*/

       else begin
           if (is_success(Locks_Check)) then begin
               if (is_critical(Locks_Check)) then begin
                   display_msg(mstr(162));
               end                                              // critical success (Locks)

               else begin
                   display_msg(mstr(163));
               end                                              // regular success (Locks)
           end

           else if (is_critical(Locks_Check)) then begin
               display_msg(mstr(164));
           end                                                  // critical Failure (Locks)

           else begin
               display_msg(mstr(165));
           end                                                  // end of regular failure (Locks)
       end                                                      // regular failure (Traps)
   end                                                          // Regular Failure (Stat_pe)

      /* Failure of a Perception Check  (Finish)*/

end


/**********************************************************************************
   This is the set of conditions for when you look at a trapped door, based on your
   traps skill and perception to notice the trap.
**********************************************************************************/

procedure Look_Traps begin
   variable Perception_Check;
   variable Traps_Check;

   Perception_Check:=do_check(dude_obj,STAT_pe,0);
   Traps_Check:=roll_vs_skill(dude_obj,SKILL_TRAPS,0);

   if (is_success(Perception_Check)) then begin
       if (is_critical(Perception_Check)) then begin
           if (is_success(Traps_Check)) then begin
               if (is_critical(Traps_Check)) then begin
                   display_msg(mstr(104));
               end                                              // Critical Success (traps)

               else begin
                   display_msg(mstr(108));
               end                                              // Regular Success (Traps)
           end

           else if (is_critical(Traps_Check)) then begin
               display_msg(mstr(112));
           end                                                  // Critical Failure (Traps)

           else begin
               display_msg(mstr(116));
           end                                                  // Regular Failure (Traps)
       end                                                      // Critical Success (Stat_Pe)

       else begin
           if (is_success(Traps_Check)) then begin
               if (is_critical(Traps_Check)) then begin
                   display_msg(mstr(120));
               end                                              // Critical Success (traps)

               else begin
                   display_msg(mstr(124));
               end                                              // Regular Success (Traps)
           end

           else if (is_critical(Traps_Check)) then begin
               display_msg(mstr(128));
           end                                                  // Critical Failure (Traps)

           else begin
               display_msg(mstr(132));
           end                                                  // Regular Failure (Traps)
       end                                                      // Regular Success (Stat_pe)
   end

   else if (is_critical(Perception_Check)) then begin
       if (is_success(Traps_Check)) then begin
           if (is_critical(Traps_Check)) then begin
               display_msg(mstr(136));
           end                                                  // Critical Success (traps)

           else begin
               display_msg(mstr(140));
           end                                                  // Regular Success (Traps)
       end

       else if (is_critical(Traps_Check)) then begin
           display_msg(mstr(144));
       end                                                      // Critical Failure (Traps)

       else begin
           display_msg(mstr(148));
       end                                                      // Regular Failure (Traps)
   end                                                          // Critical Failure (Stat_pe)

   else begin
       if (is_success(Traps_Check)) then begin
           if (is_critical(Traps_Check)) then begin
               display_msg(mstr(152));
           end                                                  // Critical Success (traps)

           else begin
               display_msg(mstr(156));
           end                                                  // Regular Success (Traps)
       end

       else if (is_critical(Traps_Check)) then begin
           display_msg(mstr(160));
       end                                                      // Critical Failure (Traps)

       else begin
           display_msg(mstr(164));
       end                                                      // Regular Failure (Traps)
   end                                                          // Regular Failure (Stat_Pe)

end


/*********************************************************************************
   This is the set of conditions for when you look at a locked door, based on your
   lockpick skill and perception to notice the lock.
*********************************************************************************/

procedure Look_Locks begin
   variable Perception_Check;
   variable Locks_Check;

   Perception_Check:=do_check(dude_obj,STAT_pe,0);
   Locks_Check:=roll_vs_skill(dude_obj,SKILL_LOCKPICK,0);

   if (is_success(Perception_Check)) then begin
       if (is_critical(Perception_Check)) then begin
           if (is_success(Locks_Check)) then begin
               if (is_critical(Locks_Check)) then begin
                   display_msg(mstr(114));
               end                                              // Critical Success (Locks)

               else begin
                   display_msg(mstr(115));
               end                                              // Regular Success (Locks)
           end

           else if (is_critical(Locks_Check)) then begin
               display_msg(mstr(116));
           end                                                  // Critical Failure (Locks)

           else begin
               display_msg(mstr(117));
           end                                                  // Regular Failure (Locks)
       end                                                      // Critical Success (Stat_Pe)

       else begin
           if (is_success(Locks_Check)) then begin
               if (is_critical(Locks_Check)) then begin
                   display_msg(mstr(130));
               end                                              // Critical Success (Locks)

               else begin
                   display_msg(mstr(131));
               end                                              // Regular Success (Locks)
           end

           else if (is_critical(Locks_Check)) then begin
               display_msg(mstr(132));
           end                                                  // Critical Failure (Locks)

           else begin
               display_msg(mstr(133));
           end                                                  // Regular Failure (Locks)
       end                                                      // Regular Success (Stat_pe)
   end

   else if (is_critical(Perception_Check)) then begin
       if (is_success(Locks_Check)) then begin
           if (is_critical(Locks_Check)) then begin
               display_msg(mstr(146));
           end                                                  // Critical Success (Locks)

           else begin
               display_msg(mstr(147));
           end                                                  // Regular Success (Locks)
       end

       else if (is_critical(Locks_Check)) then begin
           display_msg(mstr(148));
       end                                                      // Critical Failure (Locks)

       else begin
           display_msg(mstr(149));
       end                                                      // Regular Failure (Locks)
   end                                                          // Critical Failure (Stat_pe)

   else begin
       if (is_success(Locks_Check)) then begin
           if (is_critical(Locks_Check)) then begin
               display_msg(mstr(162));
           end                                                  // Critical Success (Locks)

           else begin
               display_msg(mstr(163));
           end                                                  // Regular Success (Locks)
       end

       else if (is_critical(Locks_Check)) then begin
           display_msg(mstr(164));
       end                                                      // Critical Failure (Locks)

       else begin
           display_msg(mstr(165));
       end                                                      // Regular Failure (Locks)
   end                                                          // Regular Failure (Stat_Pe)
end


/*********************************************************************************
   This procedure will do a standard Traps roll to see if the player can
   find and remove traps from the door.
*********************************************************************************/

procedure Skill_Disarm_Traps begin
/* Trap_Roll is a global variable to this script, defined at the beginning
   of the script. */

   Traps_Roll:=roll_vs_skill(source_obj,SKILL_TRAPS,Trap_Bonus);

   call Disarm_Traps;
end


/*********************************************************************************
   This procedure will allow the player to set traps on doors behind him. The door
   will need to be closed, as all traps are set to go off if the door is openned.
*********************************************************************************/

procedure Set_Trap begin
   variable Explosive;
   variable Removal_Counter;

/* Trap_Roll is a global variable to this script, defined at the beginning
   of the script. */

   Traps_Roll:=roll_vs_skill(source_obj,SKILL_TRAPS,Trap_Set_Bonus);

   Explosive:=obj_being_used_with;

   if (obj_is_open(self_obj)) then begin
       script_overrides;
       if (source_obj == dude_obj) then begin
           display_msg(mstr(206));
       end

       else begin
           display_msg(obj_name(source_obj)+mstr(207));
       end
   end

   else begin
       script_overrides;
       Removal_Counter:=rm_mult_objs_from_inven(source_obj,Explosive,1);

       if (is_success(Traps_Roll)) then begin
           set_local_var(LVAR_Trapped,STATE_ACTIVE);
           if (source_obj == dude_obj) then begin
               display_msg(mstr(208));
           end

           else begin
               display_msg(obj_name(source_obj)+mstr(210));
           end
       end

       else if (is_critical(Traps_Roll)) then begin
           call Damage_Critter;
       end

       else begin
           if (source_obj == dude_obj) then begin
               display_msg(mstr(209));
           end

           else begin
               display_msg(obj_name(source_obj)+mstr(211));
           end
       end
   end
end


/***************************************************************************
   This procedure will do a skill check vs traps to determine if the player
   or NPC finds the trap. If the trap is found, then it will check to see if
   the player or NPC set off the trap or disarms it.
***************************************************************************/

procedure Disarm_Traps begin
   if (is_success(Traps_Roll)) then begin
       if (local_var(LVAR_Found_Trap) == 0) then begin
           set_local_var(LVAR_Found_Trap,1);
           if (source_obj == dude_obj) then begin
               display_msg(mstr(194));
           end

           else begin
               display_msg(mstr(199));
           end

           if (local_var(LVAR_Gave_Traps_XP) == 0) then begin
               set_local_var(LVAR_Gave_Traps_XP,1);
               give_xp(Traps_Exp);
           end
       end

       else begin
           set_local_var(LVAR_Trapped,STATE_INACTIVE);
           if (source_obj == dude_obj) then begin
               display_msg(mstr(196));
           end

           else begin
               display_msg(obj_name(source_obj)+mstr(201));
           end
       end
   end

   else if (is_critical(Traps_Roll)) then begin
       call Damage_Critter;
   end

   else begin
       if (local_var(LVAR_Found_Trap) == 0) then begin
           if (source_obj == dude_obj) then begin
               display_msg(mstr(195));
           end

           else begin
               display_msg(obj_name(source_obj)+mstr(200));
           end
       end

       else begin
           display_msg(obj_name(source_obj)+mstr(202));
       end
   end
end


/***************************************************************************
   This procedure will just do a standard lockpick roll to see if the player
   can lockpick the door
***************************************************************************/

procedure Unlock_Lock begin
/* Locks_Roll is a global variable to this script, defined at the beginning
   of the script. */

   Locks_Roll:=roll_vs_skill(source_obj,SKILL_LOCKPICK,Lock_Bonus);

   call Lockpick_Door;
end


/***************************************************************************
   This procedure will do a lockpick roll if the player or NPC uses lockpick
   on the door. There will be a modifer from the standard roll, because the
   player will have proper tools.
***************************************************************************/

procedure Lockpick_Lock begin
/* Locks_Roll is a global variable to this script, defined at the beginning
   of the script. */
   Locks_Roll:=roll_vs_skill(source_obj,SKILL_LOCKPICK,Lockpick_Bonus);

   call Lockpick_Door;
end


/***************************************************************************
   This procedure will check against the roll_vs_lockpick to see if the
   source_object will unlock the door and display the appropriate messages
***************************************************************************/

procedure Lockpick_Door begin
   if (is_success(Locks_Roll)) then begin
       set_local_var(LVAR_Locked, STATE_INACTIVE);              // Door is unlocked
       obj_unlock(self_obj);                                    // engine unlock door

       if (source_obj == dude_obj) then begin
           display_msg(mstr(170));
       end

       else begin
           display_msg(obj_name(source_obj)+mstr(173));
       end

       if (local_var(LVAR_Gave_Locks_XP) == 0) then begin
           set_local_var(LVAR_Gave_Locks_XP,1);
           give_xp(Lockpick_Exp);
       end
   end

   else if (is_critical(Locks_Roll)) then begin
       jam_lock(self_obj);

       if (source_obj == dude_obj) then begin
           display_msg(mstr(171));
       end

       else begin
           display_msg(obj_name(source_obj)+mstr(174));
       end
   end

   else begin
       if (source_obj == dude_obj) then begin
           display_msg(mstr(172));
       end

       else begin
           display_msg(obj_name(source_obj)+mstr(175));
       end
   end
end

/***************************************************************************
   This procedure will allow the source_obj to lock the door that he had
   just unlocked.
***************************************************************************/

procedure Set_Lock begin
/* Locks_Roll is a global variable to this script, defined at the beginning
   of the script. */

   Locks_Roll:=roll_vs_skill(source_obj,SKILL_LOCKPICK,Lock_Bonus);

   call Lock_Door;
end


/***************************************************************************
   This procedure will allow the source_obj to lock the door that he had
   just unlocked using its lockpicks to accomplish this deed.
***************************************************************************/

procedure Set_Lockpick_Lock begin
/* Locks_Roll is a global variable to this script, defined at the beginning
   of the script. */

   Locks_Roll:=roll_vs_skill(source_obj,SKILL_LOCKPICK,Lockpick_Bonus);

   call Lock_Door;
end


/***************************************************************************
   This procedure will actively set the lock on the door and set all of
   the coresponding varaibles for it.
***************************************************************************/

procedure Lock_Door begin
   if (is_success(Locks_Roll)) then begin
       set_local_var(LVAR_Locked, STATE_ACTIVE);                // Door is unlocked
       obj_lock(self_obj);                                      // engine unlock door

       if (source_obj == dude_obj) then begin
           display_msg(mstr(189));
       end

       else begin
           display_msg(obj_name(source_obj)+mstr(191));
       end

       if (local_var(LVAR_Gave_Locks_XP) == 0) then begin
           set_local_var(LVAR_Gave_Locks_XP,1);
           give_xp(Lockpick_Exp);
       end
   end

   else begin
       if (source_obj == dude_obj) then begin
           display_msg(mstr(190));
       end

       else begin
           display_msg(obj_name(source_obj)+mstr(192));
       end
   end
end


/***************************************************************************
   This procedure is used should the player try to pry the door open using a
   crowbar or some similar instrument.
***************************************************************************/

procedure Pry_Door begin
   variable Stat_Roll;

   Stat_Roll:=do_check(source_obj,STAT_st,Crowbar_Bonus);

   if (is_success(Stat_Roll)) then begin
       set_local_var(LVAR_Locked, STATE_INACTIVE);
       obj_unlock(self_obj);

       if (source_obj == dude_obj) then begin
           display_msg(mstr(176));
       end

       else begin
           display_msg(mstr(181));
       end
   end

   else if (is_critical(Stat_Roll)) then begin
       critter_dmg(source_obj,Crowbar_Strain,(DMG_normal_dam BWOR DMG_BYPASS_ARMOR));

       if (source_obj == dude_obj) then begin
           if (Crowbar_Strain == 1) then begin
               display_msg(mstr(177));
           end
           else begin
               display_msg(mstr(178)+Crowbar_Strain+mstr(179));
           end
       end

       else begin
           if (get_critter_stat(source_obj,STAT_gender) == GENDER_MALE) then begin
               if (Crowbar_Strain == 1) then begin
                   display_msg(mstr(182));
               end
               else begin
                   display_msg(mstr(183)+Crowbar_Strain+mstr(184));
               end
           end

           else begin
               if (Crowbar_Strain == 1) then begin
                   display_msg(mstr(186));
               end
               else begin
                   display_msg(mstr(187)+Crowbar_Strain+mstr(188));
               end
           end
       end
   end

   else begin
       if (source_obj == dude_obj) then begin
           display_msg(mstr(180));
       end

       else begin
           display_msg(mstr(185));
       end
   end
end


/**************************************************************************************
   Should the trap go off for any reason by critter influence, then this procedure will
   be called to deal damage to the critter, display a message stating how much damage
   was taken, and remove the trap.
**************************************************************************************/

procedure Damage_Critter begin
   variable Trap_Damage;

   Trap_Damage:=random(MIN_DAMAGE,MAX_DAMAGE);

   if (source_obj == dude_obj) then begin
       critter_dmg(dude_obj,Trap_Damage,(DMG_explosion BWOR DMG_BYPASS_ARMOR));
/* display_msg("You set off the trap and were hit for "+Trap_Damage+" points of damage.);                 */
       display_msg(mstr(166)+Trap_Damage+mstr(167));
   end

   else begin
       critter_dmg(source_obj,Trap_Damage,(DMG_explosion BWOR DMG_BYPASS_ARMOR));
/* display_msg(Critter_Name+" set off the trap was hit for "+Trap_Damage+" points of damage");        */
       display_msg(obj_name(source_obj)+mstr(168)+Trap_Damage+mstr(169));
   end

/* The trap is now disarmed and should never go off again.                           */
   set_local_var(LVAR_Trapped, STATE_INACTIVE);
end
/*
	Copyright 1998-2003 Interplay Entertainment Corp.  All rights reserved.
*/

/******************************************************************************************
  Item: Wood Door
  Locked: NO
  Trapped: NO
  Closing: YES
  Description: This is a generic locked and trapped wooden door.

  Log:
  Please note any changes that have been made to the file in Updated. Then comment
  the code which you have changed/altered/commented out. Please, do not delete any
  code which was written.

  Created: September 26, 1997

  Updated:
******************************************************************************************/


/* Include Files */
#ifndef SCRIPT_REALNAME //kivicdoor includes this file, need to avoid warning
#define SCRIPT_REALNAME "ziwoddor"
#endif
#include "../headers/define.h"

#define NAME                    SCRIPT_DOOR

#include "../headers/command.h"

/* Defines and Macros */
#include "../headers/scripts.h"
#define door_mstr(x) (message_str(SCRIPT_DOOR,x))

/* Door States */
#define STATE_ACTIVE                    (0)
#define STATE_INACTIVE                  (1)
#define STATE_WOOD                      (0)
#define STATE_METAL                     (1)
#define STATE_NON_DESTROY               (2)
#define STATE_STANDARD_LOCK             (0)
#define STATE_ELECTRIC_LOCK             (1)
#define STATE_DOOR_CLOSE                (1)
#define STATE_DOOR_NOCLOSE              (0)

/* Sets whether the door is locked or trapped or closing */
#ifndef LOCKED_STATUS
  #define LOCKED_STATUS                 STATE_INACTIVE
#endif
#define TRAPPED_STATUS                  STATE_INACTIVE
#define DOOR_STATUS                     STATE_WOOD
#define LOCK_STATUS                     STATE_STANDARD_LOCK
#define CLOSE_STATUS                    STATE_DOOR_NOCLOSE

/* Penalties for Lock difficulty based on whether or not you are using lockpicks. */
#define Lock_Bonus                      (-20)
#define Lockpick_Bonus                  (Lock_Bonus+20)
#define Exd_Lockpick_Bonus              (Lock_Bonus+40)

/* Penalties for disarming the trap */
#define Trap_Bonus                      (0)
#define Trap_Set_Bonus                  (Trap_Bonus-10)

/* Penalties for forcing the door open using strength */
#ifndef Crowbar_Bonus
  #if DOOR_STATUS == STATE_METAL
    #define Crowbar_Bonus                   (-5)
  #else
    #define Crowbar_Bonus                   (-2)
  #endif
#endif
#ifndef Crowbar_Strain
  #if DOOR_STATUS == STATE_METAL
    #define Crowbar_Strain                  (4)
  #else
    #define Crowbar_Strain                  (2)
  #endif
#endif

/* Max and Min damage for the trap */
#define DOOR_STRENGTH                   (2)
#ifndef MIN_DAMAGE
  #define MIN_DAMAGE                    (20)
#endif
#ifndef MAX_DAMAGE
  #define MAX_DAMAGE                    (40)
#endif

/* Experience Points for Skills */
#define Lockpick_Exp                    EXP_LOCKPICK_NEG_20
#define Traps_Exp                       EXP_TRAPS_NORMAL

/* Door close distance */
/* How far do you want the last object that used the door to get away before it closes */
#define DOOR_CLOSE_DIST                 (3)

/* Timer id's */
#define TIMER_CLOSE                     (1)

/* Standard Script Procedures */
procedure start;
procedure use_p_proc;
procedure look_at_p_proc;
procedure description_p_proc;
procedure use_skill_on_p_proc;
procedure use_obj_on_p_proc;
procedure damage_p_proc;
procedure map_enter_p_proc;
procedure map_update_p_proc;
procedure destroy_p_proc;

/* Script Specific Procedure Calls */
procedure Look_Traps_And_Locks;
procedure Look_Traps;
procedure Look_Locks;
procedure Skill_Disarm_Traps;
procedure Disarm_Traps;
procedure Unlock_Lock;
procedure Lockpick_Lock;
procedure Lockpick_Door;
procedure Super_Lockpick_Lock;
procedure Lock_Door;
procedure Set_Lock;
procedure Set_Lockpick_Lock;
procedure Super_Set_Lockpick_Lock;
procedure Set_Trap;
procedure Pry_Door;
procedure rpu_Damage_Critter; // pbs
procedure Damage_Critter;
procedure trap_search_result(variable found_trap, variable who);
procedure real_explosion(variable explosive);
procedure roll_critical;

/*****************************************************************
Local Variables which are saved. All Local Variables need to be
prepended by LVAR_
*****************************************************************/

#define LVAR_Trapped                    (0)
#define LVAR_Found_Trap                 (1)
#define LVAR_Set_Door_Status            (2)
#define LVAR_Door_Damage                (3) // pbs
#define LVAR_Gave_Locks_XP              (4)
#define LVAR_Gave_Traps_XP              (5)
#define LVAR_Flags                      (9) // pbs

#include "../_pbs_headers/door_damage.h"
#define gave_warning_bit                bit_9
#include "../_pbs_headers/check_tamper.h"

/*******************************************************************
Imported variables from the Map scripts. These should only be
pointers and variables that need not be saved. If a variable
Needs to be saved, make it a map variable (MVAR_)
*******************************************************************/



/*******************************************************************
Local variables which do not need to be saved between map changes.
*******************************************************************/

variable Locks_Roll;
variable Traps_Roll;
variable last_source_obj;


/*******************************************************************
*******                         PROCEDURES                   *******
*******************************************************************/

// display mstr, depending on who's the object
// needs "door_mstr"
#define pcnpc_display_line(who, pc_line, npc_line) \
  if (who == dude_obj) then begin \
    display_msg(door_mstr(pc_line)); \
  end else begin \
    display_msg(obj_name(who) + door_mstr(npc_line)); \
  end
// same, but uses ready mstrs
#define pcnpc_display_str(who, pc_mstr, npc_mstr) \
  if (who == dude_obj) then begin \
    display_msg(pc_mstr); \
  end else begin \
    display_msg(obj_name(who) + npc_mstr); \
  end
procedure trap_search_result(variable found_trap, variable who) begin
  if (found_trap == 0) then begin // can't see trap
    pcnpc_display_line(who, 195, 200)
  end else begin // found trap
    pcnpc_display_line(who, 198, 200)
  end
end

/*******************************************************************
The start procedure is the first procedure called when the map is
first entered. Any initial information that needs to be set up
should be placed in here.
*******************************************************************/

procedure start begin
end

procedure timed_event_p_proc begin
  if (obj_is_open(self_obj)) then begin
    if not combat_is_initialized then begin
      if ((tile_distance_objs(dude_obj, self_obj) > DOOR_CLOSE_DIST) and
      (checkPartyMembersNearDoor == false) and
      ((tile_distance_objs(self_obj, last_source_obj) > DOOR_CLOSE_DIST) or
      (critter_state(last_source_obj) == CRITTER_IS_DEAD))) then begin
        obj_close(self_obj);
      end else begin
        add_timer_event(self_obj, 10, TIMER_CLOSE);
      end
    end else begin
      add_timer_event(self_obj, 10, TIMER_CLOSE);
    end
  end
end

/********************************************************************
Any time that a critter tries to use this door will call this
procedure. it will check to see if the door is trapped and locked.
********************************************************************/

procedure use_p_proc begin
  /* Trap_Roll is a global variable to this script, defined at the beginning
  of the script. */
  if (check_tamper) then return;

  Traps_Roll:=roll_vs_skill(source_obj,SKILL_TRAPS,Trap_Bonus);

  if (local_var(LVAR_Trapped) == STATE_ACTIVE) then begin
    if (is_success(Traps_Roll)) then begin
      script_overrides;
      set_local_var(LVAR_Found_Trap,1);
      reg_anim_clear(source_obj);

      if (source_obj == dude_obj) then begin
        display_msg(mstr(204));
      end
      else begin
        display_msg(mstr(205));
      end
    end

    else begin
      if (obj_is_locked(self_obj)) then begin
        script_overrides;
        display_msg(mstr(203));
        call Damage_Critter;
      end
      else begin
        call Damage_Critter;
      end
    end
  end

  else if (obj_is_locked(self_obj)) then begin
    script_overrides;
    display_msg(mstr(203));
  end

  //REMOVED FOLLOWING CODE SO WOODEN DOORS DONT AUTO CLOSE (Ed really hated this) -nbk
  //if (CLOSE_STATUS == STATE_DOOR_CLOSE) then begin
    //   last_source_obj := source_obj;
    //   add_timer_event(self_obj, 10, TIMER_CLOSE);
  //end
end

/***************************************************************************
This is cursory glance description that the player will receive should
he just pass the Action Cursor over. Examines which give more information
need to be in the description_p_proc procedure.
***************************************************************************/

procedure look_at_p_proc begin
  script_overrides;

  if (DOOR_STATUS == STATE_WOOD) then begin
    display_msg(mstr(100));
  end

  else begin
    display_msg(mstr(101));
  end
end


/**********************************************************************************
Should the player examine the door closely, then he should be allowed a lockpick
roll, a traps roll and a perception roll. Depending on which rolls are made will
determine how much information about the door will be given.
**********************************************************************************/

procedure description_p_proc begin
  script_overrides;
  if ((obj_is_locked(self_obj)) and (local_var(LVAR_Trapped) == STATE_ACTIVE)) then begin
    call Look_Traps_And_Locks;
  end

  else if (local_var(LVAR_Trapped) == STATE_ACTIVE) then begin
    call Look_Traps;
  end

  else if (obj_is_locked(self_obj)) then begin
    call Look_Locks;
  end

  else if (DOOR_STATUS == STATE_WOOD) then begin
    display_msg(mstr(100));
  end

  else begin
    display_msg(mstr(101));
  end
end

procedure destroy_p_proc begin
end
/**********************************************************************************
Should the player try using a skill on the door, here are where the skill rolls
will be made. The ones which need to be in here are: Lockpick and Traps. Science
and Repair can be added to this list to give more information about the door.
**********************************************************************************/

procedure use_skill_on_p_proc begin
  variable Skill_Used;
  ndebug("use_skill_on_p_proc");
  if (check_tamper) then return;

  Skill_Used:=action_being_used;

  if (Skill_Used == SKILL_LOCKPICK) then begin
    script_overrides; //added by killap
    if (obj_is_locked(self_obj)) then begin
      call Unlock_Lock;
    end
    else begin
      call Set_Lock;
    end
  end                                                          // End of Skill_Lockpick

  else if (Skill_Used == SKILL_TRAPS) then begin
    script_overrides; //added by killap
    if (local_var(LVAR_Trapped) == STATE_ACTIVE) then begin
      call Skill_Disarm_Traps;
    end
    else begin
      if (source_obj == dude_obj) then begin
        display_msg(mstr(195));
      end

      else begin
        display_msg(obj_name(source_obj)+mstr(200));
      end
    end
  end                                                          // End of Skill_Traps

end


/**********************************************************************************
This is called when the player is using an object on the door. When the check is
made to find out what is being used, obj_pid(obj_being_used_with) will need to
be checked against a prototype.
**********************************************************************************/
procedure use_obj_on_p_proc begin
  variable Tool;

  if (check_tamper) then return;
  Tool:=obj_pid(obj_being_used_with);
  if (Tool == PID_CROWBAR) then begin
    script_overrides;
    call Pry_Door;
  end
  if ((Tool == PID_DYNAMITE) or (Tool == PID_PLASTIC_EXPLOSIVES)) then begin
    script_overrides;
    call Set_Trap;
  end

  if (LOCK_STATUS == STATE_STANDARD_LOCK) then begin
    if (Tool == PID_LOCKPICKS) then begin
      script_overrides;
      if (obj_is_locked(self_obj)) then begin
        call Lockpick_Lock;
      end
      else begin
        call Set_Lockpick_Lock;
      end
    end
    else if (Tool == PID_EXP_LOCKPICK_SET) then begin
      script_overrides;
      if (obj_is_locked(self_obj)) then begin
        call Super_Lockpick_Lock;
      end
      else begin
        call Super_Set_Lockpick_Lock;
      end
    end
  end

  else if (LOCK_STATUS == STATE_ELECTRIC_LOCK) then begin
    if (Tool == PID_ELECTRONIC_LOCKPICKS) then begin
      script_overrides;
      if (obj_is_locked(self_obj)) then begin
        call Lockpick_Lock;
      end
      else begin
        call Set_Lockpick_Lock;
      end
    end
    else if (Tool == PID_ELEC_LOCKPICK_MKII) then begin
      script_overrides;
      if (obj_is_locked(self_obj)) then begin
        call Super_Lockpick_Lock;
      end
      else begin
        call Super_Set_Lockpick_Lock;
      end
    end
  end

end


/******************************************************************************************
Should the door sustain damage from anything (ie, dynamite, plastic explosives, rockets,
or any other forms of damage), this procedure will be called to destroy the door and
free up the space.
******************************************************************************************/

procedure damage_p_proc begin
  call door_damage_proc; // pbs
end


/***************************************************************************************
Whenever the map is first entered, this procedure will be called. The main purpose of
this procedure is to lock the door from the outset, rather than having to worry about
it through Mapper. After the door has been unlocked, it will remain as such, unless
the player locks it once more.
***************************************************************************************/

procedure map_enter_p_proc begin
  /* Set up the door state when the player first enters the map */
  if (is_loading_game == false) then begin
    if (local_var(LVAR_Set_Door_Status) == 0) then begin
      set_local_var(LVAR_Set_Door_Status,1);
      obj_unlock(self_obj);
      set_local_var(LVAR_Trapped,TRAPPED_STATUS);
    end

    if (LOCKED_STATUS == STATE_ACTIVE) then begin
      obj_lock(self_obj);
    end else begin
      obj_unlock(self_obj);
    end
  end
end


/**************************************************************************************
This procedure gets called roughly every 30 seconds of real time. It is used to make
sure that the door does not lock on it's own and that the player will be able to get
through once he has unlocked the door. Once more, this is so that locking and
unlocking do not need to be done in Mapper.
**************************************************************************************/

procedure map_update_p_proc begin
  if (obj_is_locked(self_obj)) then begin
    obj_lock(self_obj);
  end

  else begin
    obj_unlock(self_obj);
  end
end


/*************************************************************************************
This is the set of conditions for when you look at a locked and trapped door, based
on your lockpick and traps skills and perception to notice things.
*************************************************************************************/

procedure Look_Traps_And_Locks begin
  variable Perception_Roll;
  variable Traps_Check;
  variable Locks_Check;

  Perception_Roll = roll_vs_stat(dude_obj, STAT_pe, 0);
  Traps_Check:=roll_vs_skill(dude_obj,SKILL_TRAPS,0);
  Locks_Check:=roll_vs_skill(dude_obj,SKILL_LOCKPICK,0);

  if (is_success(Perception_Roll)) then begin

    /*************************************************************************************************/

    /* Critical Success of a Perception Check  (Start)*/

    if (is_critical(Perception_Roll)) then begin

      if (is_success(Traps_Check)) then begin
        set_local_var(LVAR_Found_Trap,1);                // player has found the trap

        /* Critical Success of a Traps Check  (Start)*/

        if (is_critical(Traps_Check)) then begin

          if (is_success(Locks_Check)) then begin
            if (is_critical(Locks_Check)) then begin
              display_msg(mstr(102));
            end                                      // critical success (Locks)

            else begin
              display_msg(mstr(103));
            end                                      // regular success (Locks)
          end

          else if (is_critical(Locks_Check)) then begin
            display_msg(mstr(104));
          end                                          // critical Failure (Locks)

          else begin
            display_msg(mstr(105));
          end                                          // end of regular failure (Locks)
        end                                              // critical success (Traps)

        /* Success of a Traps Check  (Start)*/

        else begin
          if (is_success(Locks_Check)) then begin
            if (is_critical(Locks_Check)) then begin
              display_msg(mstr(106));
            end                                      // critical success (Locks)

            else begin
              display_msg(mstr(107));
            end                                      // regular success (Locks)
          end

          else if (is_critical(Locks_Check)) then begin
            display_msg(mstr(108));
          end                                          // critical Failure (Locks)

          else begin
            display_msg(mstr(109));
          end                                          // end of regular failure (Locks)
        end                                              // regular success (Traps)
      end

      /* Critical Failure of a Traps Check  (Start)*/

      else if (is_critical(Traps_Check)) then begin
        if (is_success(Locks_Check)) then begin
          if (is_critical(Locks_Check)) then begin
            display_msg(mstr(110));
          end                                          // critical success (Locks)

          else begin
            display_msg(mstr(111));
          end                                          // regular success (Locks)
        end

        else if (is_critical(Locks_Check)) then begin
          display_msg(mstr(112));
        end                                              // critical Failure (Locks)

        else begin
          display_msg(mstr(113));
        end                                              // end of regular failure (Locks)
      end                                                   // critical Failure (Traps)

      /* Failure of a Traps Check  (Start)*/

      else begin
        if (is_success(Locks_Check)) then begin
          if (is_critical(Locks_Check)) then begin
            display_msg(mstr(114));
          end                                          // critical success (Locks)

          else begin
            display_msg(mstr(115));
          end                                          // regular success (Locks)
        end

        else if (is_critical(Locks_Check)) then begin
          display_msg(mstr(116));
        end                                              // critical Failure (Locks)

        else begin
          display_msg(mstr(117));
        end                                              // end of regular failure (Locks)
      end                                                  // regular failure (Traps)
    end                                                      // critical success (Stat_Pe)

    /* Critical Success of a Perception Check  (Finish)*/

    /*************************************************************************************************/

    /* Success of a Perception Check  (Start)*/

    else begin
      if (is_success(Traps_Check)) then begin
        set_local_var(LVAR_Found_Trap,1);                // player has found the trap

        /* Critical Success of a Traps Check  (Start)*/

        if (is_critical(Traps_Check)) then begin

          if (is_success(Locks_Check)) then begin
            if (is_critical(Locks_Check)) then begin
              display_msg(mstr(118));
            end                                      // critical success (Locks)

            else begin
              display_msg(mstr(119));
            end                                      // regular success (Locks)
          end

          else if (is_critical(Locks_Check)) then begin
            display_msg(mstr(120));
          end                                          // critical Failure (Locks)

          else begin
            display_msg(mstr(121));
          end                                          // end of regular failure (Locks)
        end                                              // critical success (Traps)

        /* Success of a Traps Check  (Start)*/

        else begin
          if (is_success(Locks_Check)) then begin
            if (is_critical(Locks_Check)) then begin
              display_msg(mstr(122));
            end                                      // critical success (Locks)

            else begin
              display_msg(mstr(123));
            end                                      // regular success (Locks)
          end

          else if (is_critical(Locks_Check)) then begin
            display_msg(mstr(124));
          end                                          // critical Failure (Locks)

          else begin
            display_msg(mstr(125));
          end                                          // end of regular failure (Locks)
        end                                              // regular success (Traps)
      end

      /* Critical Failure of a Traps Check  (Start)*/

      else if (is_critical(Traps_Check)) then begin
        if (is_success(Locks_Check)) then begin
          if (is_critical(Locks_Check)) then begin
            display_msg(mstr(126));
          end                                          // critical success (Locks)

          else begin
            display_msg(mstr(127));
          end                                          // regular success (Locks)
        end

        else if (is_critical(Locks_Check)) then begin
          display_msg(mstr(128));
        end                                              // critical Failure (Locks)

        else begin
          display_msg(mstr(129));
        end                                              // end of regular failure (Locks)
      end                                                  // critical Failure (Traps)

      /* Failure of a Traps Check  (Start)*/

      else begin
        if (is_success(Locks_Check)) then begin
          if (is_critical(Locks_Check)) then begin
            display_msg(mstr(130));
          end                                          // critical success (Locks)

          else begin
            display_msg(mstr(131));
          end                                          // regular success (Locks)
        end

        else if (is_critical(Locks_Check)) then begin
          display_msg(mstr(132));
        end                                              // critical Failure (Locks)

        else begin
          display_msg(mstr(133));
        end                                              // end of regular failure (Locks)
      end                                                  // regular failure (Traps)
    end                                                      // regular success (Stat_pe)
  end

  /* Success of a Perception Check  (Finish)*/

  /*************************************************************************************************/

  /* Critical Failure of a Perception Check  (Start)*/

  else if (is_critical(Perception_Roll)) then begin
    if (is_success(Traps_Check)) then begin
      set_local_var(LVAR_Found_Trap,1);                    // player has found the trap

      /* Critical Success of a Traps Check  (Start)*/

      if (is_critical(Traps_Check)) then begin

        if (is_success(Locks_Check)) then begin
          if (is_critical(Locks_Check)) then begin
            display_msg(mstr(134));
          end                                          // critical success (Locks)

          else begin
            display_msg(mstr(135));
          end                                          // regular success (Locks)
        end

        else if (is_critical(Locks_Check)) then begin
          display_msg(mstr(136));
        end                                              // critical Failure (Locks)

        else begin
          display_msg(mstr(137));
        end                                              // end of regular failure (Locks)
      end                                                  // critical success (Traps)

      /* Success of a Traps Check  (Start)*/

      else begin
        if (is_success(Locks_Check)) then begin
          if (is_critical(Locks_Check)) then begin
            display_msg(mstr(138));
          end                                          // critical success (Locks)

          else begin
            display_msg(mstr(139));
          end                                          // regular success (Locks)
        end

        else if (is_critical(Locks_Check)) then begin
          display_msg(mstr(140));
        end                                              // critical Failure (Locks)

        else begin
          display_msg(mstr(141));
        end                                              // end of regular failure (Locks)
      end                                                  // regular success (Traps)
    end

    /* Critical Failure of a Traps Check  (Start)*/

    else if (is_critical(Traps_Check)) then begin
      if (is_success(Locks_Check)) then begin
        if (is_critical(Locks_Check)) then begin
          display_msg(mstr(142));
        end                                              // critical success (Locks)

        else begin
          display_msg(mstr(143));
        end                                              // regular success (Locks)
      end

      else if (is_critical(Locks_Check)) then begin
        display_msg(mstr(144));
      end                                                  // critical Failure (Locks)

      else begin
        display_msg(mstr(145));
      end                                                  // end of regular failure (Locks)
    end                                                      // critical Failure (Traps)

    /* Failure of a Traps Check  (Start)*/

    else begin
      if (is_success(Locks_Check)) then begin
        if (is_critical(Locks_Check)) then begin
          display_msg(mstr(146));
        end                                              // critical success (Locks)

        else begin
          display_msg(mstr(147));
        end                                              // regular success (Locks)
      end

      else if (is_critical(Locks_Check)) then begin
        display_msg(mstr(148));
      end                                                  // critical Failure (Locks)

      else begin
        display_msg(mstr(149));
      end                                                  // end of regular failure (Locks)
    end                                                      // regular failure (Traps)
  end                                                          // Critical Failure (Stat_pe)

  /* Critical Failure of a Perception Check  (Finish)*/

  /*************************************************************************************************/

  /* Failure of a Perception Check  (Start)*/

  else begin
    if (is_success(Traps_Check)) then begin
      set_local_var(LVAR_Found_Trap,1);                    // player has found the trap

      /* Critical Success of a Traps Check  (Start)*/

      if (is_critical(Traps_Check)) then begin

        if (is_success(Locks_Check)) then begin
          if (is_critical(Locks_Check)) then begin
            display_msg(mstr(150));
          end                                          // critical success (Locks)

          else begin
            display_msg(mstr(151));
          end                                          // regular success (Locks)
        end

        else if (is_critical(Locks_Check)) then begin
          display_msg(mstr(152));
        end                                              // critical Failure (Locks)

        else begin
          display_msg(mstr(153));
        end                                              // end of regular failure (Locks)
      end                                                  // critical success (Traps)

      /* Success of a Traps Check  (Start)*/

      else begin
        if (is_success(Locks_Check)) then begin
          if (is_critical(Locks_Check)) then begin
            display_msg(mstr(154));
          end                                          // critical success (Locks)

          else begin
            display_msg(mstr(155));
          end                                          // regular success (Locks)
        end

        else if (is_critical(Locks_Check)) then begin
          display_msg(mstr(156));
        end                                              // critical Failure (Locks)

        else begin
          display_msg(mstr(157));
        end                                              // end of regular failure (Locks)
      end                                                  // regular success (Traps)
    end

    /* Critical Failure of a Traps Check  (Start)*/

    else if (is_critical(Traps_Check)) then begin
      if (is_success(Locks_Check)) then begin
        if (is_critical(Locks_Check)) then begin
          display_msg(mstr(158));
        end                                              // critical success (Locks)

        else begin
          display_msg(mstr(159));
        end                                              // regular success (Locks)
      end

      else if (is_critical(Locks_Check)) then begin
        display_msg(mstr(160));
      end                                                  // critical Failure (Locks)

      else begin
        display_msg(mstr(161));
      end                                                  // end of regular failure (Locks)
    end                                                      // critical Failure (Traps)

    /* Failure of a Traps Check  (Start)*/

    else begin
      if (is_success(Locks_Check)) then begin
        if (is_critical(Locks_Check)) then begin
          display_msg(mstr(162));
        end                                              // critical success (Locks)

        else begin
          display_msg(mstr(163));
        end                                              // regular success (Locks)
      end

      else if (is_critical(Locks_Check)) then begin
        display_msg(mstr(164));
      end                                                  // critical Failure (Locks)

      else begin
        display_msg(mstr(165));
      end                                                  // end of regular failure (Locks)
    end                                                      // regular failure (Traps)
  end                                                          // Regular Failure (Stat_pe)

  /* Failure of a Perception Check  (Finish)*/

end


/**********************************************************************************
This is the set of conditions for when you look at a trapped door, based on your
traps skill and perception to notice the trap.
**********************************************************************************/

procedure Look_Traps begin
  variable Perception_Roll;
  variable Traps_Check;

  Perception_Roll = roll_vs_stat(dude_obj, STAT_pe, 0);
  Traps_Check:=roll_vs_skill(dude_obj,SKILL_TRAPS,0);

  if (is_success(Perception_Roll)) then begin
    if (is_critical(Perception_Roll)) then begin
      if (is_success(Traps_Check)) then begin
        if (is_critical(Traps_Check)) then begin
          display_msg(mstr(104));
        end                                              // Critical Success (traps)

        else begin
          display_msg(mstr(108));
        end                                              // Regular Success (Traps)
      end

      else if (is_critical(Traps_Check)) then begin
        display_msg(mstr(112));
      end                                                  // Critical Failure (Traps)

      else begin
        display_msg(mstr(116));
      end                                                  // Regular Failure (Traps)
    end                                                      // Critical Success (Stat_Pe)

    else begin
      if (is_success(Traps_Check)) then begin
        if (is_critical(Traps_Check)) then begin
          display_msg(mstr(120));
        end                                              // Critical Success (traps)

        else begin
          display_msg(mstr(124));
        end                                              // Regular Success (Traps)
      end

      else if (is_critical(Traps_Check)) then begin
        display_msg(mstr(128));
      end                                                  // Critical Failure (Traps)

      else begin
        display_msg(mstr(132));
      end                                                  // Regular Failure (Traps)
    end                                                      // Regular Success (Stat_pe)
  end

  else if (is_critical(Perception_Roll)) then begin
    if (is_success(Traps_Check)) then begin
      if (is_critical(Traps_Check)) then begin
        display_msg(mstr(136));
      end                                                  // Critical Success (traps)

      else begin
        display_msg(mstr(140));
      end                                                  // Regular Success (Traps)
    end

    else if (is_critical(Traps_Check)) then begin
      display_msg(mstr(144));
    end                                                      // Critical Failure (Traps)

    else begin
      display_msg(mstr(148));
    end                                                      // Regular Failure (Traps)
  end                                                          // Critical Failure (Stat_pe)

  else begin
    if (is_success(Traps_Check)) then begin
      if (is_critical(Traps_Check)) then begin
        display_msg(mstr(152));
      end                                                  // Critical Success (traps)

      else begin
        display_msg(mstr(156));
      end                                                  // Regular Success (Traps)
    end

    else if (is_critical(Traps_Check)) then begin
      display_msg(mstr(160));
    end                                                      // Critical Failure (Traps)

    else begin
      display_msg(mstr(164));
    end                                                      // Regular Failure (Traps)
  end                                                          // Regular Failure (Stat_Pe)

end


/*********************************************************************************
This is the set of conditions for when you look at a locked door, based on your
lockpick skill and perception to notice the lock.
*********************************************************************************/

procedure Look_Locks begin
  variable Perception_Roll;
  variable Locks_Check;

  Perception_Roll = roll_vs_stat(dude_obj, STAT_pe, 0);
  Locks_Check:=roll_vs_skill(dude_obj,SKILL_LOCKPICK,0);

  if (is_success(Perception_Roll)) then begin
    if (is_critical(Perception_Roll)) then begin
      if (is_success(Locks_Check)) then begin
        if (is_critical(Locks_Check)) then begin
          display_msg(mstr(114));
        end                                              // Critical Success (Locks)

        else begin
          display_msg(mstr(115));
        end                                              // Regular Success (Locks)
      end

      else if (is_critical(Locks_Check)) then begin
        display_msg(mstr(116));
      end                                                  // Critical Failure (Locks)

      else begin
        display_msg(mstr(117));
      end                                                  // Regular Failure (Locks)
    end                                                      // Critical Success (Stat_Pe)

    else begin
      if (is_success(Locks_Check)) then begin
        if (is_critical(Locks_Check)) then begin
          display_msg(mstr(130));
        end                                              // Critical Success (Locks)

        else begin
          display_msg(mstr(131));
        end                                              // Regular Success (Locks)
      end

      else if (is_critical(Locks_Check)) then begin
        display_msg(mstr(132));
      end                                                  // Critical Failure (Locks)

      else begin
        display_msg(mstr(133));
      end                                                  // Regular Failure (Locks)
    end                                                      // Regular Success (Stat_pe)
  end

  else if (is_critical(Perception_Roll)) then begin
    if (is_success(Locks_Check)) then begin
      if (is_critical(Locks_Check)) then begin
        display_msg(mstr(146));
      end                                                  // Critical Success (Locks)

      else begin
        display_msg(mstr(147));
      end                                                  // Regular Success (Locks)
    end

    else if (is_critical(Locks_Check)) then begin
      display_msg(mstr(148));
    end                                                      // Critical Failure (Locks)

    else begin
      display_msg(mstr(149));
    end                                                      // Regular Failure (Locks)
  end                                                          // Critical Failure (Stat_pe)

  else begin
    if (is_success(Locks_Check)) then begin
      if (is_critical(Locks_Check)) then begin
        display_msg(mstr(162));
      end                                                  // Critical Success (Locks)

      else begin
        display_msg(mstr(163));
      end                                                  // Regular Success (Locks)
    end

    else if (is_critical(Locks_Check)) then begin
      display_msg(mstr(164));
    end                                                      // Critical Failure (Locks)

    else begin
      display_msg(mstr(165));
    end                                                      // Regular Failure (Locks)
  end                                                          // Regular Failure (Stat_Pe)
end


/*********************************************************************************
This procedure will do a standard Traps roll to see if the player can
find and remove traps from the door.
*********************************************************************************/

procedure Skill_Disarm_Traps begin
  /* Trap_Roll is a global variable to this script, defined at the beginning
  of the script. */

  Traps_Roll:=roll_vs_skill(source_obj,SKILL_TRAPS,Trap_Bonus);

  call Disarm_Traps;
end



// explosion that uses real item stats
procedure real_explosion(variable explosive) begin
  variable dmg = get_explosion_damage(obj_pid(explosive));
  pcnpc_display_line(source_obj, 610, 611)
  explosion(source_tile, self_elevation, random(dmg[0], dmg[1]));
end

/*********************************************************************************
This procedure will allow the player to set traps on doors behind him. The door
will need to be closed, as all traps are set to go off if the door is openned.
*********************************************************************************/

procedure Set_Trap begin
  variable Explosive;
  variable Removal_Counter;

  /* Trap_Roll is a global variable to this script, defined at the beginning
  of the script. */
  Traps_Roll:=roll_vs_skill(source_obj,SKILL_TRAPS,Trap_Set_Bonus);

  Explosive:=obj_being_used_with;

  if (obj_is_open(self_obj)) then begin
    script_overrides;
    if (source_obj == dude_obj) then begin
      display_msg(mstr(206));
    end

    else begin
      display_msg(obj_name(source_obj)+mstr(207));
    end
  end
  else begin
    script_overrides;
    Removal_Counter:=rm_mult_objs_from_inven(source_obj,Explosive,1);

    if (is_success(Traps_Roll)) then begin
      destroy_object(Explosive);
      set_local_var(LVAR_Trapped,STATE_ACTIVE);
      if (source_obj == dude_obj) then begin
        display_msg(mstr(208));
      end
      else begin
        display_msg(obj_name(source_obj)+mstr(210));
      end
    end

    else if (is_critical(Traps_Roll)) then begin // crit fail, explode
      call real_explosion(Explosive);
    end else begin
      move_to(Explosive, source_tile, self_elevation); // drop
      if (source_obj == dude_obj) then begin
        display_msg(mstr(209));
      end

      else begin
        display_msg(obj_name(source_obj)+mstr(211));
      end
    end
  end
end


/***************************************************************************
This procedure will do a skill check vs traps to determine if the player
or NPC finds the trap. If the trap is found, then it will check to see if
the player or NPC set off the trap or disarms it.
***************************************************************************/

procedure Disarm_Traps begin
  if (is_success(Traps_Roll)) then begin
    if (local_var(LVAR_Found_Trap) == 0) then begin
      set_local_var(LVAR_Found_Trap,1);
      if (source_obj == dude_obj) then begin
        display_msg(mstr(194));
      end

      else begin
        display_msg(mstr(199));
      end

      if (local_var(LVAR_Gave_Traps_XP) == 0) then begin
        set_local_var(LVAR_Gave_Traps_XP,1);
        give_xp(Traps_Exp);
      end
    end

    else begin
      set_local_var(LVAR_Trapped,STATE_INACTIVE);
      if (source_obj == dude_obj) then begin
        display_msg(mstr(196));
      end

      else begin
        display_msg(obj_name(source_obj)+mstr(201));
      end
    end
  end

  else if (is_critical(Traps_Roll)) then begin
    call Damage_Critter;
  end

  else begin
    if (local_var(LVAR_Found_Trap) == 0) then begin
      if (source_obj == dude_obj) then begin
        display_msg(mstr(195));
      end

      else begin
        display_msg(obj_name(source_obj)+mstr(200));
      end
    end

    else begin
      display_msg(obj_name(source_obj)+mstr(202));
    end
  end
end


/***************************************************************************
This procedure will just do a standard lockpick roll to see if the player
can lockpick the door
***************************************************************************/

procedure Unlock_Lock begin
  /* Locks_Roll is a global variable to this script, defined at the beginning
  of the script. */

  Locks_Roll:=roll_vs_skill(source_obj,SKILL_LOCKPICK,Lock_Bonus);

  call Lockpick_Door;
end


/***************************************************************************
This procedure will do a lockpick roll if the player or NPC uses lockpick
on the door. There will be a modifer from the standard roll, because the
player will have proper tools.
***************************************************************************/

procedure Lockpick_Lock begin
  /* Locks_Roll is a global variable to this script, defined at the beginning
  of the script. */
  Locks_Roll:=roll_vs_skill(source_obj,SKILL_LOCKPICK,Lockpick_Bonus);

  call Lockpick_Door;
end

procedure Super_Lockpick_Lock begin
  /* Locks_Roll is a global variable to this script, defined at the beginning
  of the script. */
  Locks_Roll:=roll_vs_skill(source_obj,SKILL_LOCKPICK,Exd_Lockpick_Bonus);

  call Lockpick_Door;
end


/***************************************************************************
This procedure will check against the roll_vs_lockpick to see if the
source_object will unlock the door and display the appropriate messages
***************************************************************************/

procedure Lockpick_Door begin
  script_overrides;
  if (is_success(Locks_Roll)) then begin
    obj_unlock(self_obj);

    if (source_obj == dude_obj) then begin
      display_msg(mstr(170));
    end

    else begin
      display_msg(obj_name(source_obj)+mstr(173));
    end

    if (local_var(LVAR_Gave_Locks_XP) == 0) then begin
      set_local_var(LVAR_Gave_Locks_XP,1);
      give_xp(Lockpick_Exp);
    end
  end

  else if (is_critical(Locks_Roll)) then begin
    jam_lock(self_obj);

    if (source_obj == dude_obj) then begin
      display_msg(mstr(171));
    end

    else begin
      display_msg(obj_name(source_obj)+mstr(174));
    end
  end

  else begin
    if (source_obj == dude_obj) then begin
      display_msg(mstr(172));
    end

    else begin
      display_msg(obj_name(source_obj)+mstr(175));
    end
  end
end

/***************************************************************************
This procedure will allow the source_obj to lock the door that he had
just unlocked.
***************************************************************************/

procedure Set_Lock begin
  /* Locks_Roll is a global variable to this script, defined at the beginning
  of the script. */
  script_overrides;
  Locks_Roll:=roll_vs_skill(source_obj,SKILL_LOCKPICK,Lock_Bonus);

  call Lock_Door;
end


/***************************************************************************
This procedure will allow the source_obj to lock the door that he had
just unlocked using its lockpicks to accomplish this deed.
***************************************************************************/

procedure Set_Lockpick_Lock begin
  /* Locks_Roll is a global variable to this script, defined at the beginning
  of the script. */

  Locks_Roll:=roll_vs_skill(source_obj,SKILL_LOCKPICK,Lockpick_Bonus);

  call Lock_Door;
end

procedure Super_Set_Lockpick_Lock begin
  /* Locks_Roll is a global variable to this script, defined at the beginning
  of the script. */

  Locks_Roll:=roll_vs_skill(source_obj,SKILL_LOCKPICK,Exd_Lockpick_Bonus);

  call Lock_Door;
end


/***************************************************************************
This procedure will actively set the lock on the door and set all of
the coresponding varaibles for it.
***************************************************************************/

procedure Lock_Door begin
  script_overrides;
  if (is_success(Locks_Roll)) then begin
    obj_lock(self_obj);                                      // engine unlock door

    if (source_obj == dude_obj) then begin
      display_msg(mstr(189));
    end

    else begin
      display_msg(obj_name(source_obj)+mstr(191));
    end

    if (local_var(LVAR_Gave_Locks_XP) == 0) then begin
      set_local_var(LVAR_Gave_Locks_XP,1);
      give_xp(Lockpick_Exp);
    end
  end

  else begin
    if (source_obj == dude_obj) then begin
      display_msg(mstr(190));
    end

    else begin
      display_msg(obj_name(source_obj)+mstr(192));
    end
  end
end


/***************************************************************************
This procedure is used should the player try to pry the door open using a
crowbar or some similar instrument.
***************************************************************************/
// For wood doors, Crowbar_Bonus = 0, which means always success
procedure roll_pry_success begin
  variable rnd = random(1,10);
  if rnd <= (get_critter_stat(source_obj,STAT_st) + Crowbar_Bonus) then return true;
  return false;
end

// Sturdier doors and high strength provide more chance to mangle the crowbar
// Any STR char + wood door = 1% chance to destroy
// 5 STR char + metal door = 10% chance to destroy
// 10 STR char + metal door = 20% chance to destroy
procedure roll_pry_destroy_crowbar begin
  variable rnd = random(1,100);
  variable str = get_critter_stat(source_obj,STAT_st);
  // Base Crowbar_Bonus = 0 (wood door). For metal doors, default is -2
  variable penalty = str * Crowbar_Bonus;
  if rnd + penalty <= 1 then return true;
  return false;
end

procedure Pry_Door begin
  variable pry_success;
  variable pry_strain;
  variable pry_destroy_crowbar;

  if not obj_is_locked(self_obj) then begin
    display_msg(mstr(601));
    return;
  end

  // crowbar destroy runs always, discouraging high STR characters from spamming it
  pry_destroy_crowbar = roll_pry_destroy_crowbar();
  if pry_destroy_crowbar then begin
    variable crowbar = get_item(source_obj, PID_CROWBAR);
    rm_obj_from_inven(source_obj, crowbar);
    destroy_object(crowbar);
    if (source_obj == dude_obj) then display_msg(mstr(620));
    else display_msg(obj_name(source_obj) + mstr(621));
    return;
  end

  pry_success = roll_pry_success();
  if pry_success then begin
    obj_unlock(self_obj);
    if (source_obj == dude_obj) then begin
      display_msg(mstr(176));
    end else begin
      display_msg(mstr(181));
    end
    return;
  end

  // failure: damage
  pry_strain = roll_critical();
  if pry_strain then begin
    critter_dmg(source_obj,Crowbar_Strain,(DMG_normal_dam BWOR DMG_BYPASS_ARMOR));

    if (source_obj == dude_obj) then begin
      if (Crowbar_Strain == 1) then begin
        display_msg(mstr(177));
      end
      else begin
        display_msg(mstr(178)+Crowbar_Strain+mstr(179));
      end
    end

    else begin
      if (is_male(source_obj)) then begin
        if (Crowbar_Strain == 1) then begin
          display_msg(mstr(182));
        end
        else begin
          display_msg(mstr(183)+Crowbar_Strain+mstr(184));
        end
      end

      else begin
        if (Crowbar_Strain == 1) then begin
          display_msg(mstr(186));
        end
        else begin
          display_msg(mstr(187)+Crowbar_Strain+mstr(188));
        end
      end
    end
  end

  // regular failure
  if not pry_strain then begin
    if (source_obj == dude_obj) then display_msg(mstr(180));
    else display_msg(mstr(185));
  end


end

procedure rpu_Damage_Critter begin
  variable Trap_Damage;
  Trap_Damage:=random(MIN_DAMAGE,MAX_DAMAGE);
  reg_anim_clear(source_obj); // prevent "you were hit for no damage" from the next line when running through a closed door
  explosion(self_tile, self_elevation, 0); // just the animation
  pcnpc_display_str(source_obj, door_mstr(166)+Trap_Damage+door_mstr(167), door_mstr(168)+Trap_Damage+door_mstr(169))
  critter_heal(source_obj, -Trap_Damage);
  set_local_var(LVAR_Trapped, STATE_INACTIVE);
  return Trap_Damage;
end

procedure Damage_Critter begin
  variable trapDmg := rpu_Damage_Critter;
  call damage_door(trapDmg); // damage door itself
end

// Unbiased critical, used for prying with Crowbar.
procedure roll_critical begin
  variable rnd = random(1,20);
  if rnd == 20 then return true;
  return false;
end

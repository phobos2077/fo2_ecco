/*
   Map Loot tweaker

   Allows to run commands at specific tiles to adjust loot on the map:
   - Add/remove items to/from critter/container/ground.
   - Wield weapons.
*/

#include "../sfall/sfall.h"
#include "../sfall/lib.arrays.h"
#include "../sfall/lib.inven.h"
#include "../sfall/define_lite.h"

variable
   config,
   command_stats;

#define CUR_MAP_CONFIG  config[""+cur_map_index]

#define debug_log(msg)		debug_msg("pbs_map_loot: "+msg)
#define debug_err(msg)		debug_msg("! ERROR ! pbs_map_loot: "+msg)

#define format_cmd_log(msg, tile)   (tile + ": " + msg)
#define debug_log_cmd(msg, tile)		debug_log(format_cmd_log(msg, tile))
#define debug_err_cmd(msg, tile)		debug_err(format_cmd_log(msg, tile))

procedure start begin
   config := get_ini_config_db("config\\map_loot.ini");
   debug_log(debug_array_str(config));
end

procedure parse_map_config begin
   variable mapConfig := config[""+cur_map_index];
   if (not mapConfig) then return false;

   variable tiles;
end

procedure find_loot_target(variable tileNum, variable elev) begin
   variable obj, objs := tile_get_objs(tileNum, elev);
   foreach (obj in objs) begin
      if (obj_type(obj) == OBJ_TYPE_CRITTER) then
         return obj;
   end
   foreach (obj in objs) begin
      if (obj_type(obj) == OBJ_TYPE_ITEM and obj_item_subtype(obj) == item_type_container) then
         return obj;
   end
   return 0; // use ground
end

procedure create_loot_object(variable pid, variable tileNum, variable elev, variable ammo, variable ammoPid) begin
   variable obj := create_object_sid(pid, tileNum, elev, -1);
   if (obj_type(obj) == OBJ_TYPE_ITEM) then begin
      if (ammo >= 0) then
         set_weapon_ammo_count(obj, ammo);
      if (ammoPid > 0) then
         set_weapon_ammo_pid(obj, ammoPid);
   end
   return obj;
end

#define arg_or_default(i, def)     atoi(args[i]) if args[i] else def
#define loot_target_name(invenObj) (obj_name(invenObj) if invenObj else "ground")

procedure command_add(variable tileNum, variable elev, variable invenObj, variable args) begin
   variable
      pid := arg_or_default(0, 0),
      count := arg_or_default(1, 1),
      ammo := arg_or_default(2, -1),
      ammoPid := arg_or_default(3, -1);

   if (not pid) then begin
      debug_err_cmd("a: invalid pid", tileNum);
      return;
   end
   variable i, obj := create_loot_object(pid, tileNum, elev, ammo, ammoPid);
   if (invenObj) then begin
      add_mult_objs_to_inven(invenObj, obj, count);
   end else begin
      for (i := 1; i < count; i++) begin
         call create_loot_object(pid, tileNum, elev, ammo, ammoPid);
      end
   end
   debug_log_cmd(string_format3("added %s(%d) to %s", obj_name(obj), count, loot_target_name(invenObj)), tileNum);
end

procedure command_remove(variable tileNum, variable elev, variable invenObj, variable args) begin
   variable
      pid := arg_or_default(0, 0),
      count := arg_or_default(1, 1),
      numRemoved;

   if (not pid) then begin
      debug_err_cmd("r: invalid pid", tileNum);
      return;
   end
   if (invenObj) then begin
      // Remove from inventory.
      numRemoved := remove_items_pid(invenObj, pid, count);
   end else begin
      // Remove from ground (this can delete any object, not just item!).
      variable obj, objs := tile_get_objs(tileNum, elev);
      foreach (obj in objs) begin
         if (obj_pid(obj) == pid) then begin
            destroy_object(obj);
            numRemoved++;
            if (numRemoved == count) then
               break;
         end
      end
   end
   debug_log_cmd(string_format3("removed %s(%d) from %s", proto_data(pid, it_name), count, loot_target_name(invenObj)), tileNum);
end

procedure command_wield(variable tileNum, variable elev, variable invenObj, variable args) begin
   variable
      pid := arg_or_default(0, 0);

   if (not pid) then begin
      debug_err_cmd("w: invalid pid", tileNum);
      return;
   end
   if (not invenObj or obj_type(invenObj) != OBJ_TYPE_CRITTER) then begin
      debug_err_cmd("w: no critter found!", tileNum);
      return;
   end
   variable item := obj_carrying_pid_obj(invenObj, pid);
   if (not item) then begin
      debug_err_cmd("w: item not found by pid: "+pid, tileNum);
      return;
   end
   wield_obj_critter(invenObj, item);
   debug_log_cmd(obj_name(invenObj) + " wields " + obj_name(item), tileNum);
end


procedure execute_command(variable cmdStr, variable tileNum, variable elev, variable invenObj) begin
   variable
      cmd := cmdStr[0],
      args := string_split(substr(cmdStr, 1, 0), ":");

   switch (cmd) begin
      case "a":
         call command_add(tileNum, elev, invenObj, args);
      case "r":
         call command_remove(tileNum, elev, invenObj, args);
      case "w":
         call command_wield(tileNum, elev, invenObj, args);
      default:
         debug_err_cmd("unknown command: "+cmd, tileNum);
   end
end

// Main logic goes here
procedure map_enter_p_proc begin
   if (cur_town == -1 or is_loading_game or not map_first_run) then return;

   variable elev;
   for (elev := 0; elev <= 2; elev++) begin
      variable mapElevConfig := config[cur_map_index + "_" + elev];
      if (not mapElevConfig) then continue;

      debug_log("Running commands for elev "+elev);
      variable tileNum, cmds, cmd, invenObj;
      foreach (tileNum: cmds in mapElevConfig) begin
         tileNum := atoi(tileNum);
         invenObj := find_loot_target(tileNum, elev);
         cmds := string_split(cmds, ",");
         foreach (cmd in cmds) begin
            call execute_command(cmd, tileNum, elev, invenObj);
         end
      end
   end
end

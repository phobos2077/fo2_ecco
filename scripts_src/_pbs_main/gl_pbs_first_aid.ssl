/*
   First aid tweaks:
   - Healing items immediate heal amount will be scaled with First Aid skill (player only).
*/
#define SCRIPT_REALNAME             "pbs_first_aid"

#include "../sfall/sfall.h"
#include "../sfall/lib.arrays.h"
#include "../sfall/lib.math.h"
//#include "../sfall/lib.obj.h"
#include "../sfall/define_lite.h"
#include "../sfall/define_extra.h"

#include "../headers/itempid.h"

#include "../_pbs_headers/engine_funcs.h"
#include "../_pbs_headers/math_ext.h"
#include "../_pbs_headers/ecco_ids.h"
#include "../_pbs_headers/ecco_ini.h"
#include "../_pbs_headers/ecco_log.h"
#include "../_pbs_headers/ecco_msg.h"

#define INI_FILE        INI_MISC
#define INI_SECTION     "FIRST_AID"

#define HI_STAT_MIN_HP     (1)
#define HI_STAT_MAX_HP     (2)

variable begin
   ini_healing_drug_pids;
   ini_healing_mult_min;
   ini_healing_mult_max;
   ini_healing_skill_max;
   default_stats;
end

#define is_scalable_healing_item(itemPid)          (proto_data(itemPid, it_type) == item_type_drug and is_in_array(itemPid, ini_healing_drug_pids))

procedure remember_default_stats begin
   variable pid, stats;
   default_stats := create_array_map;
   foreach (pid in ini_healing_drug_pids) begin
      default_stats[pid] := array_fixed({
         HI_STAT_MIN_HP: get_proto_data(pid, PROTO_DR_AMOUNT_1_A),
         HI_STAT_MAX_HP: get_proto_data(pid, PROTO_DR_AMOUNT_1_B)
      });
   end
end

procedure calculate_healing_min_max(variable itemPid, variable user, variable forDisplay := false) begin
   variable
      defaultMinHp := default_stats[itemPid][HI_STAT_MIN_HP],
      defaultMaxHp := default_stats[itemPid][HI_STAT_MAX_HP],
      skill := has_skill(user, SKILL_FIRST_AID),
      skillFactor := math_min(1.0 * skill / ini_healing_skill_max, 1.0),
      mult := ini_healing_mult_min + (ini_healing_mult_max - ini_healing_mult_min) * skillFactor,
      minHp := defaultMinHp * mult,
      maxHp := (defaultMaxHp * mult) if (defaultMaxHp > 0) else 0;
   
   if (forDisplay) then begin
      minHp := floor(minHp);
      maxHp := ceil(maxHp);
   end else begin
      minHp := math_round_chance(minHp);
      maxHp := math_max(math_round_chance(maxHp), minHp) if (maxHp > 0) else 0;
   end
   return [minHp, maxHp];
end


/*
procedure is_healing_item(variable item) begin

   variable itemPid := obj_pid(item), hpStatIsA, hpStatIsB, hpAmt;
   if (obj_type(item) != OBJ_TYPE_ITEM or proto_data(itemPid, it_type) != item_type_drug) then return false;

   hpStatIsA := (get_proto_data(itemPid, PROTO_DR_STAT_A) == STAT_current_hp);
   hpStatIsB := (get_proto_data(itemPid, PROTO_DR_STAT_B) == STAT_current_hp);
   if (not hpStatIsA and not hpStatIsB) then return false;

   hpAmt := get_proto_data(itemPid, PROTO_DR_AMOUNT_1_A) if hpStatIsA else get_proto_data(itemPid, PROTO_DR_AMOUNT_1_B);
   return hpAmt > 0;
end
*/

/*
Runs when using the examine action icon to display the description of an object. You can override the description text. An example usage would be to add an additional description to the item based on player's stats/skills.

Does not run if the script of the object overrides the description.

NOTE: Returning a pointer to the new text received from the get_string_pointer function is still valid, but the method is DEPRECATED and is left for backward compatibility only.

Obj     arg0 - the object

String  ret0 - the new description text to use
*/
procedure descriptionobj_hook begin
   variable
      obj := get_sfall_arg,
      objPid := obj_pid(obj),
      healAmt, str;

   if ((obj_type(obj) != OBJ_TYPE_ITEM) or (not is_scalable_healing_item(objPid))) then return;

   healAmt := calculate_healing_min_max(objPid, dude_obj, true);
   str := string_format(mstr_ecco_combat(300), healAmt[0], healAmt[1])
      if (healAmt[1] > 0)
      else string_format(mstr_ecco_combat(301), healAmt[0]);
   set_sfall_return(message_str_game(GAME_MSG_PRO_ITEM, get_proto_data(objPid, PROTO_TEXTID) + 1) + str);
end

#define COMBAT_STATE_FLEEING     (4)

#define critter_max_hp(cr)       get_critter_stat(cr, STAT_max_hit_points)
#define critter_body_type(cr)    proto_data(obj_pid(cr), cr_body_type)
#define critter_dmg_flags(cr)    get_object_data(cr, OBJ_DATA_DAMAGE_FLAGS)
#define critter_combat_flags(cr) get_object_data(cr, OBJ_DATA_COMBAT_STATE)


#define clear_critter_flag(cr, offset, flag)  set_object_data(cr, offset, get_object_data(cr, offset) bwand bwnot(flag))
#define clear_critter_dmg_flag(cr, flag)      clear_critter_flag(cr, OBJ_DATA_DAMAGE_FLAGS, flag)
#define clear_critter_combat_flag(cr, flag)   clear_critter_flag(cr, OBJ_DATA_COMBAT_STATE, flag)

// SKILL USE SSL implementation

#define SKILL_COUNT                (18)
#define SKILLS_MAX_USES_PER_DAY     (3)

variable times_skill_used, healable_damage_flags, healing_skill_items;

procedure skill_use_slot_available(variable skill) begin
   variable slot, time, hoursSinceLastUsage,
      skillOffset := skill * SKILLS_MAX_USES_PER_DAY;

   // Lazy init array
   if (not times_skill_used) then
      times_skill_used := create_array_list(SKILL_COUNT * SKILLS_MAX_USES_PER_DAY);

   for (slot := 0; slot < SKILLS_MAX_USES_PER_DAY; slot++) begin
      if (times_skill_used[skillOffset + slot] == 0) then
         return slot;
   end
   time := game_time;
   hoursSinceLastUsage = (time - times_skill_used[skillOffset + 0]) / ONE_GAME_HOUR;
   if (hoursSinceLastUsage <= 24) then begin
      return -1;
   end
   return SKILLS_MAX_USES_PER_DAY - 1;
end

procedure skill_use_slot_add(variable skill) begin
   variable i,
      slot := skill_use_slot_available(skill),
      skillOffset := skill * SKILLS_MAX_USES_PER_DAY;
   if (slot == -1) then
      return -1;

   if (times_skill_used[skillOffset + slot] != 0) then begin
      for (i := 0; i < slot; i++) begin
         times_skill_used[skillOffset + i] := times_skill_used[skillOffset + i + 1];
      end
   end

   times_skill_used[skillOffset + slot] = game_time;
   return 0;
end

procedure use_slot_unavailable_display_msg(variable skill) begin
   if (skill_use_slot_available(SKILL_FIRST_AID) == -1) then begin
      // 590: You've taxed your ability with that skill. Wait a while.
      // 591: You're too tired.
      // 592: The strain might kill you.
      display_msg(mstr_skill(590 + random(0, 2)));
      return true;
   end
   return false;
end

procedure critter_is_dead_display_msg(variable target, variable msgId := 0) begin
   if (critter_is_dead(target)) then begin
      // 512: You can't heal the dead.
      // 513: Let the dead rest in peace.
      // 514: It's dead, get over it.
      display_msg(mstr_skill((512 + random(0, 2)) if (msgId == 0) else msgId));
      return true;
   end
   return false;
end

/**
 * A refactored version of skill_use function from the engine, for use with healing skills only. Returns true if skill use was successful.
 * @arg {ObjectPtr} user
 * @arg {ObjectPtr} target
 * @arg {int} skill - First Aid, Doctor or Repair
 * @arg {int} skillBonus
 */
procedure use_healing_skill(variable user, variable target, variable skill, variable skillBonus) begin
   variable curHp, maxHp, healingAttempts, isRobot, isRepair, isFirstAid;

   display_msg(string_format("use_healing_skill: user = %s, target = %s, bonus = %d, skill = %d", obj_name(user), obj_name(target), skillBonus, skill));
   
   isRobot := (critter_body_type(target) == CR_BODY_ROBOTIC);
   isRepair := (skill == SKILL_REPAIR);
   if (isRepair and not isRobot) then begin
      // You cannot repair that.
      display_msg(mstr_skill(553));
      return false;
   end
   if (skill_use_slot_available(skill) == -1) then begin
      // 590: You've taxed your ability with that skill. Wait a while.
      // 591: You're too tired.
      // 592: The strain might kill you.
      display_msg(mstr_skill(590 + random(0, 2)));
      return false;
   end
   if (critter_is_dead(target)) then begin
      // 512: You can't heal the dead.
      // 513: Let the dead rest in peace.
      // 514: It's dead, get over it.
      display_msg(mstr_skill(512 + random(0, 2)));
      return false;
   end

   isFirstAid := (skill == SKILL_FIRST_AID);

   curHp := critter_cur_hp(target);
   maxHp := critter_max_hp(target);
   healingAttempts := 1;
   if (curHp < maxHp or (not isFirstAid and critter_is_crippled(target))) then begin
      variable skillUseSlotAdded, roll, i, prefixMsg,
         critChance := get_critter_stat(user, STAT_crit_chance) + skillBonus;

      fade_out;

      // Heal crippled limbs.
      if (not isFirstAid and (not isRepair or not isRobot) and critter_is_crippled(target)) then begin
         // Lazy init healable flags
         if (not healable_damage_flags) then
            healable_damage_flags := array_fixed([
               DAM_BLIND,
               DAM_CRIP_ARM_LEFT,
               DAM_CRIP_ARM_RIGHT,
               DAM_CRIP_LEG_RIGHT,
               DAM_CRIP_LEG_LEFT
            ]);

         for (i := 0; i < len_array(healable_damage_flags); i++) begin
            if (not critter_has_dmg_flag(target, healable_damage_flags[i])) then
               continue;

            healingAttempts += 1;
            roll := roll_vs_skill(user, skill, critChance);
            if (roll == ROLL_SUCCESS or roll == ROLL_CRITICAL_SUCCESS) then begin
               clear_critter_dmg_flag(target, healable_damage_flags[i]);
               clear_critter_combat_flag(target, COMBAT_STATE_FLEEING);
               // 520: You heal your %s.
               // 521: You heal the %s.
               prefixMsg := 520 if (target == dude_obj) else 521;
               call skill_use_slot_add(skill);
               skillUseSlotAdded := true;
            end else begin
               // 525: You fail to heal your %s.
               // 526: You fail to heal the %s.
               prefixMsg := 525 if (target == dude_obj) else 526;
            end
            // 530: damaged eye
            // 531: crippled left arm
            // 532: crippled right arm
            // 533: crippled right leg
            // 534: crippled left leg
            display_msg(sprintf(mstr_skill(prefixMsg), mstr_skill(530 + i)));
            if (user == dude_obj) then
               call show_skill_use_messages(skill);
         end
      end

      // Restore hit points.
      roll := (roll_vs_skill(user, skill, critChance) if isFirstAid else roll_check(has_skill(user, skill), critChance))
         if (isRepair or not isRobot)
         else ROLL_FAILURE;

      if (roll == ROLL_SUCCESS or roll == ROLL_CRITICAL_SUCCESS) then begin
         variable
            minHpToHeal := (1 if isFirstAid else 4),
            maxHpToHeal := (5 if isFirstAid else 10),
            hpToHeal;
         if (user == dude_obj and not isRepair) then begin
            variable healerRank := has_trait(TRAIT_PERK, user, PERK_healer);
            minHpToHeal += 4 * healerRank;
            maxHpToHeal += 10 * healerRank;
         end
         hpToHeal = random(minHpToHeal, maxHpToHeal);
         critter_heal(target, hpToHeal);

         if (user == dude_obj) then begin
            // You heal %d hit points.
            display_msg(sprintf(mstr_skill(500), math_min(maxHp - curHp, hpToHeal)));
         end

         if (not skillUseSlotAdded) then
            call skill_use_slot_add(skill);

         clear_critter_combat_flag(target, COMBAT_STATE_FLEEING);
         if (user == dude_obj) then
            call show_skill_use_messages(skill);
      end else begin
         // You fail to do any healing.
         display_msg(sprintf(mstr_skill(503), how_much(0)));
      end

      fade_in;
   end else if (user == dude_obj) then begin
      // 501: You look healty already
      // 502: %s looks healthy already
      display_msg(mstr_skill(501)
         if (target == dude_obj)
         else sprintf(mstr_skill(502), obj_name(target)));
   end
   if (user == dude_obj) then begin
      game_time_advance((ONE_GAME_HOUR if (skill == SKILL_DOCTOR) else (30 * ONE_GAME_MINUTE)) * healingAttempts);
   end
   // TODO: not sure if this is needed
   //exec_map_update_scripts
end

/**
 * A partial copy of engine's protinst_use_item_on with code pertinent to healing skills. Returns value for set_sfall_return in useobjon_hook.
 * @arg {ObjectPtr} user - item user
 * @arg {ObjectPtr} target - target
 * @arg {ObjectPtr} item - item
 * @ret {bool}
 */
procedure protinst_use_item_on(variable user, variable target, variable item) begin
   variable begin
      messageId := -1;
      skillBonus := 0;
      skill := -1;
   end
   switch (obj_pid(item)) begin
      case PID_DOCTORS_BAG: begin
         // The supplies in the Doctor's Bag run out.
         messageId = 900;
         skillBonus = 20;
         skill = SKILL_DOCTOR;
      end
      case PID_FIRST_AID_KIT: begin
         // The supplies in the First Aid Kit run out.
         messageId = 901;
         skillBonus = 20;
         skill = SKILL_FIRST_AID;
      end
      case PID_PARAMEDICS_BAG: begin
         // The supplies in the Paramedic's Bag run out.
         messageId = 910;
         skillBonus = 40;
         skill = SKILL_DOCTOR;
      end
      case PID_FIELD_MEDIC_KIT: begin
         // The supplies in the Field Medic First Aid Kit run out.
         messageId = 911;
         skillBonus = 40;
         skill = SKILL_FIRST_AID;
      end
   end
   if (skill == -1) then
      return -1;
   
   if (combat_is_initialized) then begin
      // You cannot do that in combat.
      if (user == dude_obj) then
         display_msg(mstr_proto(902));
      return 0;
   end

   if (not use_healing_skill(user, target, skill, skillBonus)) then
      return 0;

   if (random(1, 10) != 1) then
      return 0;

   if (user == dude_obj) then
      display_msg(mstr_proto(messageId));

   return 1;
end

/*
Runs when:

a critter uses an object on another critter. (Or themselves)
a critter uses an object from inventory screen AND this object does not have "Use" action flag set and it's not active flare or explosive.
player or AI uses any drug
This is fired before the object is used, and the relevant use_obj_on script procedures are run. You can disable default item behavior.

NOTE: You can't remove and/or destroy this object during the hookscript (game will crash otherwise). To remove it, return 1.

Critter arg0 - The target
Critter arg1 - The user
int     arg2 - The object used

int     ret0 - overrides hard-coded handler and selects what should happen with the item (0 - place it back, 1 - remove it, -1 - use engine handler)
*/
procedure useobjon_hook begin
   variable
      target := get_sfall_arg,
      user := get_sfall_arg,
      item := get_sfall_arg,
      itemPid := obj_pid(item),
      useItemResult;

   //display_msg(string_format("%s tries to use %s (%d)", obj_name(user), obj_name(item), proto_data(itemPid, it_type)));
   if (is_scalable_healing_item(itemPid)) then begin
      if (user == dude_obj) then begin
         variable
            healingAmt := calculate_healing_min_max(itemPid, user);

         set_proto_data(itemPid, PROTO_DR_AMOUNT_1_A, healingAmt[0]);
         set_proto_data(itemPid, PROTO_DR_AMOUNT_1_B, healingAmt[1]);
         debug_log(string_format("Changed %s min: %d, max: %d", obj_name(item), healingAmt[0], healingAmt[1]));
      end else begin // for NPC's always use defaults
         set_proto_data(itemPid, PROTO_DR_AMOUNT_1_A, default_stats[itemPid][HI_STAT_MIN_HP]);
         set_proto_data(itemPid, PROTO_DR_AMOUNT_1_B, default_stats[itemPid][HI_STAT_MAX_HP]);
      end
   end

   useItemResult := protinst_use_item_on(user, target, item);
   if (useItemResult != -1) then
      set_sfall_return(useItemResult);
end

/*
Runs when using any skill on any object.

This is fired before the default handlers are called, which you can override. In this case you should write your own skill use handler entirely, or otherwise nothing will happen (this includes fade in/fade out, time lapsing and messages - all of this can be scripted; to get vanilla text messages - use message_str_game along with sprintf). Suggested use - override First Aid/Doctor skills to buff/nerf them, override Steal skill to disallow observing NPCs inventories in some cases.

Does not run if the script of the object calls script_overrides for using the skill.

Critter arg0 - The user critter
Obj     arg1 - The target object
int     arg2 - skill being used
int     arg3 - skill bonus from items such as first aid kits

int     ret0 - overrides hard-coded handler (-1 - use engine handler, any other value - override; if it is 0, there will be a 10% chance of removing the used medical item)
*/
procedure useskill_hook begin
   variable
      user := get_sfall_arg,
      target := get_sfall_arg,
      skill := get_sfall_arg,
      skillBonus := get_sfall_arg,
      isSuccess;

   if (skill == SKILL_FIRST_AID or skill == SKILL_DOCTOR or skill == SKILL_REPAIR) then begin
      isSuccess := use_healing_skill(user, target, skill, skillBonus);
      set_sfall_return(0 if isSuccess else 1);
   end
   
   // TODO: skill usage limits, exp gain, dead critter check, robotic check, skill roll, screen fade
   /*if (skill == SKILL_FIRST_AID) then begin
      display_msg(string_format("user = %s, target = %s, bonus = %d", obj_name(user), obj_name(target), skillBonus));
      
      if (curHp < maxHp) then begin
         toHeal := math_min(maxHp - curHp, 5);
         critter_heal(target, toHeal);
         if (user == dude_obj) then begin
            display_msg(sprintf(mstr_skill(500), toHeal));
         end
         set_object_data(target, OBJ_DATA_COMBAT_STATE, get_object_data(target, OBJ_DATA_COMBAT_STATE) bwand (-5)); // remove fleeing flag
      end
   end*/

end

procedure start begin
   if (game_loaded) then begin
      int_list_from_ini_file(healing_drug_pids, INI_FILE, INI_SECTION);
      float_from_ini_file_clamped(healing_mult_min, INI_FILE, INI_SECTION, 0.0, 10.0);
      float_from_ini_file_clamped(healing_mult_max, INI_FILE, INI_SECTION, ini_healing_mult_min, 10.0);
      int_from_ini_file_clamped(healing_skill_max, INI_FILE, INI_SECTION, 0, 300);

      call remember_default_stats;

      register_hook_proc(HOOK_USEOBJON, useobjon_hook);
      register_hook_proc(HOOK_USESKILL, useskill_hook);
      if (ini_healing_skill_max > 0 and ini_healing_mult_max > 0.01) then begin
         register_hook_proc(HOOK_DESCRIPTIONOBJ, descriptionobj_hook);
      end
   end
end

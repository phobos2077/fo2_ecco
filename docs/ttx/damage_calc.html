<!DOCTYPE html>
<html>
<head>
    <title>FO2 Damage Calc</title>
</head>
<body>

<h1>Damage Calc</h1>

<label for="dataset">DATA SET:</label>
<select id="dataset">
</select>

<br/><br/>

<label for="weapon">Weapon:</label>
<select id="weapon">
</select>

<label for="ammo">Ammo:</label>
<select id="ammo">
</select>

<label for="rounds">Rounds:</label>
<select id="rounds">
</select>

<label for="difficulty">Difficulty:</label>
<select id="difficulty">
</select>

<label for="critMult">Critical Multiplier:</label>
<select id="critMult">
</select>

<label for="critBypass">Critical Bypass:</label>
<input type="checkbox" id="critBypass"></input>

<br/><br/>

<label for="formula">Formula:</label>
<select id="formula">
</select>

<label for="mode" style="display: none">Display mode:</label>
<select id="mode" style="display: none">
    <option value="dmg">Damage</option>
    <option value="dt">Effective DT</option>
    <option value="dr">Effective DR</option>
</select>

<h2 id="dmgType"></h2>
<table id="results">
    <thead>
        <tr><th>Armor:</th></tr>
        <tr><th>DT:</th></tr>
        <tr><th>Ef.DT:</th></tr>
        <tr><th>DR:</th></tr>
        <tr><th>Ef.DR:</th></tr>
    </thead>
    <tbody></tbody>
</table>

<canvas id="graph" width="700" height="300"></canvas>

<script type="text/javascript" src="damage_calc_datasets.js"></script>
<script type="text/javascript" src="damage_calc_formulas.js"></script>
<script type="text/javascript" src="damage_calc_loadcsv.js"></script>
<script type="text/javascript">

/**
 * @type Armor[]
 */
let armors = [];
let weapons = [];
let ammoTypes = [];

let lastCtx = {};


function intRange(min, max) {
    let arr = [];
    for (let i = min; i <= max; i++) {
        arr.push(i);
    }
    return arr;
}

const getSelectValue = id => document.getElementById(id).value;
const getSelectValueInt = id => parseInt(getSelectValue(id));
const getCheckboxChecked = id => document.getElementById(id).checked;

let lastSettings = {
    dataSet: 0,
    selected: {},
};

function getLastSetting(id) {
    const dataSetId = getSelectValueInt("dataset");
    return lastSettings.selected[dataSetId] && lastSettings.selected[dataSetId][id];
}

function updateCheckbox(id) {
    const inputEl = document.getElementById(id);
    inputEl.checked = getLastSetting(id);
}

function fillOptions(selectId, arr, defaultVal) {
    const selectEl = document.getElementById(selectId);
    selectEl.innerHTML = "";
    for (let i = 0; i < arr.length; i++) {
        let option = document.createElement("option");
        option.value = typeof(arr[i]) == "object" ? i : arr[i];
        option.textContent = arr[i].name || arr[i];
        selectEl.appendChild(option);
    }
    const lastVal = getLastSetting(selectId);
    if (lastVal) {
        selectEl.value = lastVal;
    } else if (defaultVal) {
        selectEl.value = defaultVal;
    }
}

function loadSettings() {
    let rawSettings = sessionStorage.getItem("settings");
    if (rawSettings) {
        lastSettings = JSON.parse(rawSettings);
    }
}

function saveSettings() {
    const dataSetId = getSelectValueInt("dataset");
    lastSettings.dataSet = dataSetId;
    ["weapon","formula","critMult","critBypass","mode","difficulty","ammo","rounds"]
        .forEach(id => {
            const selectedForDataset = lastSettings.selected[dataSetId] = lastSettings.selected[dataSetId] || {};
            const el = document.getElementById(id);
            selectedForDataset[id] = typeof(el.checked) == "boolean" ? el.checked : el.value;
        });

    //console.log("Saving", selected);
    sessionStorage.setItem("settings", JSON.stringify(lastSettings));
}

async function initialize() {
    loadSettings();
    fillOptions("dataset", dataSets, lastSettings.dataSet);

    await loadDataset();
}

async function loadDataset() {
    await loadDataFromCsv(dataSets[getSelectValueInt("dataset")]);

    //console.log(armors, ammoTypes, weapons);
    
    fillOptions("weapon", weapons);
    fillOptions("formula", damageFormulas);
    fillOptions("critMult", [2,3,4,6,8]);
    fillOptions("difficulty", [75,100,125], 100);
    updateCheckbox("critBypass");

    updateTable();
}

/**
 * @param {number[]} dataRow
 * @param {number} baseDmg
 * @param {DamageContext} dmgCtx
 */
function drawGraph(dataRow, baseDmg, dmgCtx) {
    //console.log("drawGraph", dmg, dataRow);
    if (dataRow.length <= 0) return;
    /**
     * @type HTMLCanvasElement
     */
    const canvas = document.getElementById("graph");
    const ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const margin = 20;
    const top = margin;
    const left = margin;
    const right = canvas.width - margin;
    const bottom = canvas.height - margin;
    const width = canvas.width - margin * 2;
    const height = canvas.height - margin * 2;

    function damageToY(dmg) {
        return bottom - dmg / dmgCtx.maxFinalDmg * height;
    }
    const dmgLines = [];
    function addDmgLine(value) {
        const y = damageToY(value);
        if (dmgLines.some(ly => Math.abs(y - ly) < 10)) return;
        dmgLines.push(y);

        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = "#bbb";
        ctx.moveTo(left, y);
        ctx.lineTo(right, y);
        ctx.stroke();

        ctx.font = "14px arial";
        ctx.strokeStyle = "black";
        ctx.fillText(value, left, y);
    }
    addDmgLine(0);
    addDmgLine(baseDmg);
    addDmgLine(dmgCtx.weapon.dmgMin);
    addDmgLine(dmgCtx.weapon.dmgMax);
    addDmgLine(dmgCtx.maxFinalDmg);

    ctx.beginPath();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "red";
    let x = left + margin,
        y = damageToY(dataRow[0]);
    ctx.moveTo(x, y);
    ctx.arc(x, y, 3, 0, 360);
    const stepX = width / dataRow.length;
    for (let i = 1; i < dataRow.length; i++) {
        x += stepX;
        y = damageToY(dataRow[i]);

        ctx.lineTo(x, y);
        ctx.arc(x, y, 3, 0, 360);
        //console.log(margin + stepX * i, damageToY(dataRow[i]));
    }
    ctx.stroke();
    ctx.closePath();
}

function updateTable() {
    console.log("Updating table...");

    /**
     * @type DamageContext
     */
    const ctx = {
        weapon: weapons[getSelectValueInt("weapon")],
        formula: damageFormulas[getSelectValueInt("formula")],
        difficulty: getSelectValueInt("difficulty"),
        crit: {
            mult: getSelectValueInt("critMult"),
            bypass: getCheckboxChecked("critBypass")
        },
        formulaMode: getSelectValue("mode"),
        bonusRanged: 0,
    };
    if (!lastCtx || lastCtx.weapon != ctx.weapon) {
        ctx.weaponAmmoTypes = ammoTypes.filter(at => at.caliber == ctx.weapon.caliber);
        fillOptions("ammo", ctx.weaponAmmoTypes);
        fillOptions("rounds", intRange(1, ctx.weapon.burst || 1));
    } else {
        ctx.weaponAmmoTypes = lastCtx.weaponAmmoTypes;
    }
    ctx.ammo = ctx.weaponAmmoTypes[getSelectValueInt("ammo")];
    ctx.rounds = getSelectValueInt("rounds");

    //console.log(ctx);
    if (!ctx.weapon || !ctx.formula || !ctx.difficulty || !ctx.crit.mult || !ctx.formulaMode) return;

    saveSettings();

    lastCtx = ctx;
    ctx.dmgType = damageTypes[ctx.weapon.dmgType];
    ctx.dmgTypeIdx = ctx.weapon.dmgType;

    document.getElementById("dmgType").textContent = damageTypes[ctx.dmgTypeIdx] + " Damage";
    
    const tableElement = document.getElementById("results");
    const tableBody = tableElement.getElementsByTagName("tbody")[0];
    tableBody.innerHTML = "";
    
    // Update table header
    let tableHeaderRows = tableElement.getElementsByTagName("thead")[0].rows;
    
    // Clear existing header cells
    for (let i = 0; i < tableHeaderRows.length; i++) {
        while (tableHeaderRows[i].cells.length > 1) {
            tableHeaderRows[i].deleteCell(1);
        }
    }

    
    function calculateDamage(dmg, armor) {
        ctx.armor = armor;
        ctx.rawDmg = dmg;
        return ctx.formula.dmg(ctx);
    }
    const relevantArmors = armors.slice();
    relevantArmors.sort((a, b) => {
        /*if (b.type == "critter" && b.type != a.type) {
            return -1;
        }*/
        const dmg = ctx.weapon.dmgMin;
        const dmgDif = calculateDamage(dmg, b) - calculateDamage(dmg, a);
        return dmgDif != 0
            ? dmgDif
            : a.dr[ctx.dmgTypeIdx] - b.dr[ctx.dmgTypeIdx];
    });
    for (let i = 1; i < relevantArmors.length; i++) {
        const a = relevantArmors[i], b = relevantArmors[i - 1];
        const dmgType = ctx.dmgTypeIdx;
        if (a.dt[dmgType] == b.dt[dmgType] &&
            a.dr[dmgType] == b.dr[dmgType] &&
            a.type == b.type)
        {
            relevantArmors.splice(i, 1);
            i--;
        }
    }
    
    const addHeaderCell = function(rowIdx, value) {
        let cell = document.createElement("th");
        cell.textContent = value;
        tableHeaderRows[rowIdx].appendChild(cell);
    }
    // Populate header cells based on armor types from array
    relevantArmors.forEach(armor => {
        let dt, dr;
        ctx.armor = armor;
        [dt, dr] = ctx.formula.dtdr(ctx);
        addHeaderCell(0, armor.name);
        addHeaderCell(1, armor.dt[ctx.dmgTypeIdx]);
        addHeaderCell(2, dt);
        addHeaderCell(3, armor.dr[ctx.dmgTypeIdx]+"%");
        addHeaderCell(4, dr+"%");
    });

    const addBodyCell = function(row, value) {
        let cell = document.createElement("td");
        cell.textContent = value;
        row.appendChild(cell);
        return cell;
    }
    // Update table body
    let maxFinalDmg = -Infinity;
    for (let baseDmg = ctx.weapon.dmgMin; baseDmg <= ctx.weapon.dmgMax; baseDmg++) {
        const row = document.createElement("tr");
        addBodyCell(row, baseDmg);

        const dataRow = relevantArmors.map(armor => calculateDamage(baseDmg, armor));
        dataRow.forEach(finalDmg => {
            addBodyCell(row, finalDmg.toFixed())
                .addEventListener("mouseenter", function () {
                    drawGraph(dataRow, baseDmg, ctx);
                })
        });

        tableBody.appendChild(row);
        maxFinalDmg = dataRow.reduce((a, b) => Math.max(a, b), maxFinalDmg);
    }
    ctx.maxFinalDmg = maxFinalDmg;
}

document.addEventListener("DOMContentLoaded", function() {
  initialize();
});

document.getElementById("dataset").addEventListener("change", loadDataset);

["weapon","ammo","formula","critMult","critBypass","mode","difficulty","rounds"].forEach(id => {
    document.getElementById(id).addEventListener("change", updateTable);
});


</script>
<style>
    /*#results th {
        border-width: 0 0 0 0;
    }*/
    #results {
        border-collapse: collapse;
    }
    #results tr:last-child > th {
        border-bottom: 1px solid;
    }
    #results td, #results th {
        max-width: 50px;
    }
    #results td {
        text-align: center;
    }
    #results th {
        font-weight: normal;
    }
    #results thead > tr:first-child > th:not(:first-child) {
        font-size: small;
        transform: rotate(-30deg);
    }
    #results td:first-child, #results th:first-child, #results thead > tr:first-child > th {
        font-weight: bold;
    }
    #results td:first-child, #results th:first-child {
        border-right: 1px solid;
    }
    #results tr:hover {
        background-color: #ddd;
    }
</style>
</body>
</html>